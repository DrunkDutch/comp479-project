{"url": "http://www.w3.org/TR/1998/REC-xml-19980210", "content": "Extensible Markup Language (XML) 1.0 \n REC-xml-19980210 Extensible Markup Language (XML) 1.0 \n W3C Recommendation \n10-February-1998  \n This version: \nhttp://www.w3.org/TR/1998/REC-xml-19980210 \nhttp://www.w3.org/TR/1998/REC-xml-19980210.xml \nhttp://www.w3.org/TR/1998/REC-xml-19980210.html \nhttp://www.w3.org/TR/1998/REC-xml-19980210.pdf \nhttp://www.w3.org/TR/1998/REC-xml-19980210.ps \n Latest version: \nhttp://www.w3.org/TR/REC-xml \n Previous version: \nhttp://www.w3.org/TR/PR-xml-971208 \n Editors: \n Tim Bray\n (Textuality and Netscape) \n <tbray@textuality.com> \n Jean Paoli\n (Microsoft) \n <jeanpa@microsoft.com> \n C. M. Sperberg-McQueen\n (University of Illinois at Chicago) \n <cmsmcq@uic.edu> \n Abstract \n The Extensible Markup Language (XML) is a subset of\nSGML that is completely described in this document. Its goal is to\nenable generic SGML to be served, received, and processed on the Web\nin the way that is now possible with HTML. XML has been designed for\nease of implementation and for interoperability with both SGML and\nHTML. \n Status of this document \n This document has been reviewed by W3C Members and\nother interested parties and has been endorsed by the\nDirector as a W3C Recommendation. It is a stable\ndocument and may be used as reference material or cited\nas a normative reference from another document. W3C's\nrole in making the Recommendation is to draw attention\nto the specification and to promote its widespread\ndeployment. This enhances the functionality and\ninteroperability of the Web. \nThis document specifies a syntax created by subsetting an existing,\nwidely used international text processing standard (Standard\nGeneralized Markup Language, ISO 8879:1986(E) as amended and\ncorrected) for use on the World Wide Web.  It is a product of the W3C\nXML Activity, details of which can be found at  http://www.w3.org/XML .  A list of\ncurrent W3C Recommendations and other technical documents can be found\nat  http://www.w3.org/TR .\n This specification uses the term URI, which is defined by  [Berners-Lee et al.] , a work in progress expected to update  [IETF RFC1738]  and  [IETF RFC1808] . \n The list of known errors in this specification is \navailable at \n http://www.w3.org/XML/xml-19980210-errata . \n Please report errors in this document to \n xml-editor@w3.org .\n Extensible Markup Language (XML) 1.0 Table of Contents 1.  Introduction \n\u00a0\u00a0\u00a0\u00a01.1  Origin and Goals \n\u00a0\u00a0\u00a0\u00a01.2  Terminology \n2.  Documents \n\u00a0\u00a0\u00a0\u00a02.1  Well-Formed XML Documents \n\u00a0\u00a0\u00a0\u00a02.2  Characters \n\u00a0\u00a0\u00a0\u00a02.3  Common Syntactic Constructs \n\u00a0\u00a0\u00a0\u00a02.4  Character Data and Markup \n\u00a0\u00a0\u00a0\u00a02.5  Comments \n\u00a0\u00a0\u00a0\u00a02.6  Processing Instructions \n\u00a0\u00a0\u00a0\u00a02.7  CDATA Sections \n\u00a0\u00a0\u00a0\u00a02.8  Prolog and Document Type Declaration \n\u00a0\u00a0\u00a0\u00a02.9  Standalone Document Declaration \n\u00a0\u00a0\u00a0\u00a02.10  White Space Handling \n\u00a0\u00a0\u00a0\u00a02.11  End-of-Line Handling \n\u00a0\u00a0\u00a0\u00a02.12  Language Identification \n3.  Logical Structures \n\u00a0\u00a0\u00a0\u00a03.1  Start-Tags, End-Tags, and Empty-Element Tags \n\u00a0\u00a0\u00a0\u00a03.2  Element Type Declarations \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.2.1  Element Content \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.2.2  Mixed Content \n\u00a0\u00a0\u00a0\u00a03.3  Attribute-List Declarations \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.3.1  Attribute Types \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.3.2  Attribute Defaults \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.3.3  Attribute-Value Normalization \n\u00a0\u00a0\u00a0\u00a03.4  Conditional Sections \n4.  Physical Structures \n\u00a0\u00a0\u00a0\u00a04.1  Character and Entity References \n\u00a0\u00a0\u00a0\u00a04.2  Entity Declarations \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.2.1  Internal Entities \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.2.2  External Entities \n\u00a0\u00a0\u00a0\u00a04.3  Parsed Entities \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.3.1  The Text Declaration \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.3.2  Well-Formed Parsed Entities \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.3.3  Character Encoding in Entities \n\u00a0\u00a0\u00a0\u00a04.4  XML Processor Treatment of Entities and References \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.4.1  Not Recognized \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.4.2  Included \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.4.3  Included If Validating \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.4.4  Forbidden \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.4.5  Included in Literal \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.4.6  Notify \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.4.7  Bypassed \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.4.8  Included as PE \n\u00a0\u00a0\u00a0\u00a04.5  Construction of Internal Entity Replacement Text \n\u00a0\u00a0\u00a0\u00a04.6  Predefined Entities \n\u00a0\u00a0\u00a0\u00a04.7  Notation Declarations \n\u00a0\u00a0\u00a0\u00a04.8  Document Entity \n5.  Conformance \n\u00a0\u00a0\u00a0\u00a05.1  Validating and Non-Validating Processors \n\u00a0\u00a0\u00a0\u00a05.2  Using XML Processors \n6.  Notation \n Appendices A.  References \n\u00a0\u00a0\u00a0\u00a0A.1  Normative References \n\u00a0\u00a0\u00a0\u00a0A.2  Other References \nB.  Character Classes \nC.  XML and SGML (Non-Normative) \nD.  Expansion of Entity and Character References (Non-Normative) \nE.  Deterministic Content Models (Non-Normative) \nF.  Autodetection of Character Encodings (Non-Normative) \nG.  W3C XML Working Group (Non-Normative) \n 1. Introduction \n Extensible Markup Language, abbreviated XML, describes a class of\ndata objects called  XML documents  and\npartially describes the behavior of \ncomputer programs which process them. XML is an application profile or\nrestricted form of SGML, the Standard Generalized Markup \nLanguage  [ISO 8879] .\nBy construction, XML documents \nare conforming SGML documents.\n XML documents are made up of storage units called  entities , which contain either parsed\nor unparsed data.\nParsed data is made up of  characters ,\nsome \nof which form  character data , \nand some of which form  markup .\nMarkup encodes a description of the document's storage layout and\nlogical structure. XML provides a mechanism to impose constraints on\nthe storage layout and logical structure. \n A software module\ncalled an  XML processor  is used to read XML documents\nand provide access to their content and structure.  It is assumed that an XML processor is\ndoing its work on behalf of another module, called the\n application . This specification describes the\nrequired behavior of an XML processor in terms of how it must read XML\ndata and the information it must provide to the application. \n 1.1 Origin and Goals \n XML was developed by an XML Working Group (originally known as the\nSGML Editorial Review Board) formed under the auspices of the World\nWide Web Consortium (W3C) in 1996.\nIt was chaired by Jon Bosak of Sun\nMicrosystems with the active participation of an XML Special\nInterest Group (previously known as the SGML Working Group) also\norganized by the W3C. The membership of the XML Working Group is given\nin an appendix. Dan Connolly served as the WG's contact with the W3C.\n The design goals for XML are: \n XML shall be straightforwardly usable over the\nInternet. \n XML shall support a wide variety of applications. \n XML shall be compatible with SGML. \n It shall be easy to write programs which process XML\ndocuments. \n The number of optional features in XML is to be kept to the\nabsolute minimum, ideally zero. \n XML documents should be human-legible and reasonably\nclear. \n The XML design should be prepared quickly. \n The design of XML shall be formal and concise. \n XML documents shall be easy to create. \n Terseness in XML markup is of minimal importance. \n This specification, \ntogether with associated standards\n(Unicode and ISO/IEC 10646 for characters,\nInternet RFC 1766 for language identification tags, \nISO 639 for language name codes, and \nISO 3166 for country name codes),\nprovides all the information necessary to understand \nXML Version 1.0\nand construct computer programs to process it. \n This version of the XML specification\nmay be distributed freely, as long as\nall text and legal notices remain intact. \n 1.2 Terminology \n The terminology used to describe XML documents is defined in the body of\nthis specification.\nThe terms defined in the following list are used in building those\ndefinitions and in describing the actions of an XML processor:\n may \n Conforming documents and XML\nprocessors are permitted to but need not behave as\ndescribed. \n must \n Conforming documents and XML processors \nare required to behave as described; otherwise they are in error.\n error \n A violation of the rules of this\nspecification; results are\nundefined.  Conforming software may detect and report an error and may\nrecover from it. \n fatal error \n An error\nwhich a conforming  XML processor \nmust detect and report to the application.\nAfter encountering a fatal error, the\nprocessor may continue\nprocessing the data to search for further errors and may report such\nerrors to the application.  In order to support correction of errors,\nthe processor may make unprocessed data from the document (with\nintermingled character data and markup) available to the application.\nOnce a fatal error is detected, however, the processor must not\ncontinue normal processing (i.e., it must not\ncontinue to pass character data and information about the document's\nlogical structure to the application in the normal way).\n at user option \n Conforming software may or must (depending on the modal verb in the\nsentence) behave as described; if it does, it must\nprovide users a means to enable or disable the behavior\ndescribed. \n validity constraint \n A rule which applies to all \n valid  XML documents.\nViolations of validity constraints are errors; they must, at user option, \nbe reported by \n validating XML processors . \n well-formedness constraint \n A rule which applies to all  well-formed  XML documents.\nViolations of well-formedness constraints are \n fatal errors . \n match \n (Of strings or names:) \nTwo strings or names being compared must be identical.\nCharacters with multiple possible representations in ISO/IEC 10646 (e.g.\ncharacters with \nboth precomposed and base+diacritic forms) match only if they have the\nsame representation in both strings.\nAt user option, processors may normalize such characters to\nsome canonical form.\nNo case folding is performed. \n(Of strings and rules in the grammar:)  \nA string matches a grammatical production if it belongs to the\nlanguage generated by that production.\n(Of content and content models:)\nAn element matches its declaration when it conforms\nin the fashion described in the constraint\n\" Element Valid \".\n for compatibility \n A feature of\nXML included solely to ensure that XML remains compatible with SGML.\n for interoperability \n A\nnon-binding recommendation included to increase the chances that XML\ndocuments can be processed by the existing installed base of SGML\nprocessors which predate the\nWebSGML Adaptations Annex to ISO 8879. \n 2. Documents \nA data object is an\n XML document  if it is\n well-formed , as\ndefined in this specification.\nA well-formed XML document may in addition be\n valid  if it meets certain further \nconstraints. \n Each XML document has both a logical and a physical structure.\nPhysically, the document is composed of units called  entities .  An entity may  refer  to other entities to cause their\ninclusion in the document. A document begins in a \"root\"  or  document entity .\nLogically, the document is composed of declarations, elements, \ncomments,\ncharacter references, and\nprocessing\ninstructions, all of which are indicated in the document by explicit\nmarkup.\nThe logical and physical structures must nest properly, as described  \nin \" 4.3.2\u00a0Well-Formed Parsed Entities \".\n 2.1 Well-Formed XML Documents \nA textual object is \na well-formed XML document if:\n Taken as a whole, it\nmatches the production labeled  document . \n It\nmeets all the well-formedness constraints given in this specification.\n Each of the  parsed entities  \nwhich is referenced directly or indirectly within the document is\n well-formed . \nDocument \n [1]\u00a0 document \n  ::=  prolog \n element \n Misc * \n Matching the  document  production \nimplies that:\n It contains one or more\n elements .\n There is  exactly\none element, called the  root , or document element,  no\npart of which appears in the  content  of any other element.\nFor all other elements, if the start-tag is in the content of another\nelement, the end-tag is in the content of the same element.  More\nsimply stated, the elements, delimited by start- and end-tags, nest\nproperly within each other.\n As a consequence \nof this,\nfor each non-root element\n C  in the document, there is one other element  P \nin the document such that \n C  is in the content of  P , but is not in\nthe content of any other element that is in the content of\n P .  \n P  is referred to as the\n parent  of  C , and  C  as a\n child  of  P . \n 2.2 Characters \n A parsed entity contains\n text , a sequence of \n characters , \nwhich may represent markup or character data. \n A  character  \nis an atomic unit of text as specified by\nISO/IEC 10646  [ISO/IEC 10646] .\nLegal characters are tab, carriage return, line feed, and the legal\ngraphic characters of Unicode and ISO/IEC 10646.\nThe use of \"compatibility characters\", as defined in section 6.8\nof  [Unicode] , is discouraged.\nCharacter Range \n [2]\u00a0 Char \n  ::=  #x9 |\u00a0#xA |\u00a0#xD |\u00a0[#x20-#xD7FF] |\u00a0[#xE000-#xFFFD] \n|\u00a0[#x10000-#x10FFFF] \n  /*  any Unicode character, excluding the\nsurrogate blocks, FFFE, and FFFF. */   \n The mechanism for encoding character code points into bit patterns may\nvary from entity to entity. All XML processors must accept the UTF-8\nand UTF-16 encodings of 10646; the mechanisms for signaling which of\nthe two is in use, or for bringing other encodings into play, are\ndiscussed later, in \" 4.3.3\u00a0Character Encoding in Entities \".\n 2.3 Common Syntactic Constructs \n This section defines some symbols used widely in the grammar. \n S  (white space) consists of one or more space (#x20)\ncharacters, carriage returns, line feeds, or tabs.\nWhite Space \n [3]\u00a0 S \n  ::=  (#x20 |\u00a0#x9 |\u00a0#xD |\u00a0#xA)+ \n Characters are classified for convenience as letters, digits, or other\ncharacters.  Letters consist of an alphabetic or syllabic \nbase character possibly\nfollowed by one or more combining characters, or of an ideographic\ncharacter.  \nFull definitions of the specific characters in each class\nare given in \" B.\u00a0Character Classes \". \n A  Name  is a token\nbeginning with a letter or one of a few punctuation characters, and continuing\nwith letters, digits, hyphens, underscores, colons, or full stops, together\nknown as name characters.\nNames beginning with the string \" xml \", or any string\nwhich would match  (('X'|'x') ('M'|'m') ('L'|'l')) , are\nreserved for standardization in this or future versions of this\nspecification.\n Note:  The colon character within XML names is reserved for experimentation with\nname spaces.  \nIts meaning is expected to be\nstandardized at some future point, at which point those documents \nusing the colon for experimental purposes may need to be updated.\n(There is no guarantee that any name-space mechanism\nadopted for XML will in fact use the colon as a name-space delimiter.)\nIn practice, this means that authors should not use the colon in XML\nnames except as part of name-space experiments, but that XML processors\nshould accept the colon as a name character. \n An\n Nmtoken  (name token) is any mixture of\nname characters.\nNames and Tokens \n [4]\u00a0 NameChar \n  ::=  Letter  \n|\u00a0 Digit  \n|\u00a0'.' |\u00a0'-' |\u00a0'_' |\u00a0':'\n|\u00a0 CombiningChar  \n|\u00a0 Extender \n [5]\u00a0 Name \n  ::=  ( Letter  |\u00a0'_' |\u00a0':')\n( NameChar )* \n [6]\u00a0 Names \n  ::=  Name  \n( S   Name )* \n [7]\u00a0 Nmtoken \n  ::=  ( NameChar )+ \n [8]\u00a0 Nmtokens \n  ::=  Nmtoken  ( S   Nmtoken )* \n Literal data is any quoted string not containing\nthe quotation mark used as a delimiter for that string.\nLiterals are used\nfor specifying the content of internal entities\n( EntityValue ),\nthe values of attributes ( AttValue ), \nand external identifiers \n( SystemLiteral ).  \nNote that a  SystemLiteral \ncan be parsed without scanning for markup.\nLiterals \n [9]\u00a0 EntityValue \n  ::=  '\"' \n([^%&\"] \n|\u00a0 PEReference  \n|\u00a0 Reference )*\n'\"' \n |\u00a0 \n\"'\" \n([^%&'] \n|\u00a0 PEReference  \n|\u00a0 Reference )* \n\"'\" \n [10]\u00a0 AttValue \n  ::=  '\"' \n([^<&\"] \n|\u00a0 Reference )* \n'\"' \n |\u00a0 \n\"'\" \n([^<&'] \n|\u00a0 Reference )* \n\"'\" \n [11]\u00a0 SystemLiteral \n  ::=  ('\"' [^\"]* '\"') |\u00a0(\"'\" [^']* \"'\")\n [12]\u00a0 PubidLiteral \n  ::=  '\"'  PubidChar * \n'\"' \n|\u00a0\"'\" ( PubidChar  - \"'\")* \"'\" \n [13]\u00a0 PubidChar \n  ::=  #x20 |\u00a0#xD |\u00a0#xA \n|\u00a0[a-zA-Z0-9]\n|\u00a0[-'()+,./:=?;!*#@$_%] \n 2.4 Character Data and Markup \n Text  consists of intermingled \n character\ndata  and markup.\n Markup  takes the form of\n start-tags ,\n end-tags ,\n empty-element tags ,\n entity references ,\n character references ,\n comments ,\n CDATA section  delimiters,\n document type declarations , and\n processing instructions .\n All text that is not markup\nconstitutes the  character data  of\nthe document. \n The ampersand character (&) and the left angle bracket (<)\nmay appear in their literal form  only  when used as markup\ndelimiters, or within a  comment , a\n processing instruction , \nor a  CDATA section .  \nThey are also legal within the  literal entity\nvalue  of an internal entity declaration; see\n\" 4.3.2\u00a0Well-Formed Parsed Entities \".\nIf they are needed elsewhere,\nthey must be  escaped \nusing either  numeric character references \nor the strings\n\" &amp; \" and \" &lt; \" respectively. \nThe right angle\nbracket (>) may be represented using the string\n\" &gt; \", and must,  for\ncompatibility , \nbe escaped using\n\" &gt; \" or a character reference \nwhen it appears in the string\n\" ]]> \"\nin content, \nwhen that string is not marking the end of \na  CDATA section . \nIn the content of elements, character data \nis any string of characters which does\nnot contain the start-delimiter of any markup.  \nIn a CDATA section, character data\nis any string of characters not including the CDATA-section-close\ndelimiter, \" ]]> \". \nTo allow attribute values to contain both single and double quotes, the\napostrophe or single-quote character (') may be represented as\n\" &apos; \", and the double-quote character (\") as\n\" &quot; \".\nCharacter Data \n [14]\u00a0 CharData \n  ::=  [^<&]* - ([^<&]* ']]>' [^<&]*) \n 2.5 Comments \n Comments  may \nappear anywhere in a document outside other \n markup ; in addition,\nthey may appear within the document type declaration\nat places allowed by the grammar.\nThey are not part of the document's  character\ndata ; an XML\nprocessor may, but need not, make it possible for an application to\nretrieve the text of comments.\n For compatibility , the string\n\" -- \" (double-hyphen) must not occur within\ncomments.\nComments \n [15]\u00a0 Comment \n  ::=  '<!--'\n(( Char  - '-') \n|\u00a0('-' ( Char  - '-')))* \n'-->' \n An example of a comment:\n <!--\u00a0declarations\u00a0for\u00a0<head>\u00a0&\u00a0<body>\u00a0--> \n 2.6 Processing Instructions \n Processing\ninstructions  (PIs) allow documents to contain instructions\nfor applications.\nProcessing Instructions \n [16]\u00a0 PI \n  ::=  '<?'  PITarget  \n( S  \n( Char * - \n( Char * '?>'  Char *)))?\n'?>' \n [17]\u00a0 PITarget \n  ::=  Name  - \n(('X' |\u00a0'x') ('M' |\u00a0'm') ('L' |\u00a0'l')) \nPIs are not part of the document's  character\ndata , but must be passed through to the application. The\nPI begins with a target ( PITarget ) used\nto identify the application to which the instruction is directed.  \nThe target names \" XML \", \" xml \", and so on are\nreserved for standardization in this or future versions of this\nspecification.\nThe \nXML  Notation  mechanism\nmay be used for\nformal declaration of PI targets.\n 2.7 CDATA Sections \n CDATA sections \nmay occur \nanywhere character data may occur; they are\nused to escape blocks of text containing characters which would\notherwise be recognized as markup.  CDATA sections begin with the\nstring \" <![CDATA[ \" and end with the string\n\" ]]> \":\nCDATA Sections \n [18]\u00a0 CDSect \n  ::=  CDStart \n CData \n CDEnd \n [19]\u00a0 CDStart \n  ::=  '<![CDATA[' \n [20]\u00a0 CData \n  ::=  ( Char * - \n( Char * ']]>'  Char *))\n [21]\u00a0 CDEnd \n  ::=  ']]>' \nWithin a CDATA section, only the  CDEnd  string is\nrecognized as markup, so that left angle brackets and ampersands may occur in\ntheir literal form; they need not (and cannot) be escaped using\n\" &lt; \" and \" &amp; \".  CDATA sections\ncannot nest.\n An example of a CDATA section, in which \" <greeting> \" and \n\" </greeting> \"\nare recognized as  character data , not\n markup :\n <![CDATA[<greeting>Hello,\u00a0world!</greeting>]]> \n 2.8 Prolog and Document Type Declaration \n XML documents \nmay, and should, \nbegin with an  XML declaration  which specifies\nthe version of\nXML being used.\nFor example, the following is a complete XML document,  well-formed  but not\n valid :\n <?xml\u00a0version=\"1.0\"?> <greeting>Hello,\u00a0world!</greeting> \nand so is this:\n <greeting>Hello,\u00a0world!</greeting> \n The version number \" 1.0 \" should be used to indicate\nconformance to this version of this specification; it is an error\nfor a document to use the value \" 1.0 \" \nif it does not conform to this version of this specification.\nIt is the intent\nof the XML working group to give later versions of this specification\nnumbers other than \" 1.0 \", but this intent does not\nindicate a\ncommitment to produce any future versions of XML, nor if any are produced, to\nuse any particular numbering scheme.\nSince future versions are not ruled out, this construct is provided \nas a means to allow the possibility of automatic version recognition, should\nit become necessary.\nProcessors may signal an error if they receive documents labeled with \nversions they do not support. \n The function of the markup in an XML document is to describe its\nstorage and logical structure and to associate attribute-value pairs\nwith its logical structures.  XML provides a mechanism, the  document type declaration , to define\nconstraints on the logical structure and to support the use of\npredefined storage units.\n An XML document is \n valid  if it has an associated document type\ndeclaration and if the document\ncomplies with the constraints expressed in it. \n The document type declaration must appear before\nthe first  element  in the document.\nProlog \n [22]\u00a0 prolog \n  ::=  XMLDecl ? \n Misc * \n( doctypedecl \n Misc *)? \n [23]\u00a0 XMLDecl \n  ::=  '<?xml' \n VersionInfo \n EncodingDecl ? \n SDDecl ? \n S ? \n'?>' \n [24]\u00a0 VersionInfo \n  ::=  S  'version'  Eq  \n('  VersionNum  ' \n|\u00a0\"  VersionNum  \") \n [25]\u00a0 Eq \n  ::=  S ? '='  S ? \n [26]\u00a0 VersionNum \n  ::=  ([a-zA-Z0-9_.:] |\u00a0'-')+ \n [27]\u00a0 Misc \n  ::=  Comment  |\u00a0 PI  |\u00a0\n S \n The XML\n document type declaration  \ncontains or points to \n markup declarations  \nthat provide a grammar for a\nclass of documents.  \nThis grammar is known as a document type definition,\nor  DTD .  \nThe document type declaration can point to an external subset (a\nspecial kind of \n external entity ) containing markup\ndeclarations, or can \ncontain the markup declarations directly in an internal subset, or can do\nboth.   \nThe DTD for a document consists of both subsets taken\ntogether.\nA  markup declaration  is \nan  element type declaration , \nan  attribute-list declaration , \nan  entity declaration , or\na  notation declaration .\nThese declarations may be contained in whole or in part\nwithin  parameter entities ,\nas described in the well-formedness and validity constraints below.\nFor fuller information, see\n\" 4.\u00a0Physical Structures \". \nDocument Type Definition \n [28]\u00a0 doctypedecl \n  ::=  '<!DOCTYPE'  S \n Name  ( S \n ExternalID )? \n S ? ('[' \n( markupdecl  \n|\u00a0 PEReference  \n|\u00a0 S )*\n']' \n S ?)? '>' \n  [  VC:  Root Element Type  ] \n [29]\u00a0 markupdecl \n  ::=  elementdecl  \n|\u00a0 AttlistDecl  \n|\u00a0 EntityDecl  \n|\u00a0 NotationDecl  \n|\u00a0 PI  \n|\u00a0 Comment \n  [  VC:  Proper Declaration/PE Nesting  ] \n  [  WFC:  PEs in Internal Subset  ] \n The markup declarations may be made up in whole or in part of\nthe  replacement text  of \n parameter entities .\nThe productions later in this specification for\nindividual nonterminals ( elementdecl ,\n AttlistDecl , and so on) describe \nthe declarations  after  all the parameter entities have been \n included . \n Validity Constraint: \nRoot Element Type \nThe  Name  in the document type declaration must\nmatch the element type of the  root element .\n Validity Constraint: \nProper Declaration/PE Nesting \nParameter-entity \n replacement text  must be properly nested\nwith markup declarations. \nThat is to say, if either the first character\nor the last character of a markup\ndeclaration ( markupdecl  above)\nis contained in the replacement text for a \n parameter-entity reference ,\nboth must be contained in the same replacement text.\n Well-Formedness Constraint: \nPEs in Internal Subset \nIn the internal DTD subset, \n parameter-entity references \ncan occur only where markup declarations can occur, not\nwithin markup declarations.  (This does not apply to\nreferences that occur in\nexternal parameter entities or to the external subset.)\nLike the internal subset, the external subset and \nany external parameter entities referred to in the DTD \nmust consist of a series of complete markup declarations of the types \nallowed by the non-terminal symbol\n markupdecl , interspersed with white space\nor  parameter-entity references .\nHowever, portions of the contents\nof the \nexternal subset or of external parameter entities may conditionally be ignored\nby using \nthe  conditional section \nconstruct; this is not allowed in the internal subset.\nExternal Subset \n [30]\u00a0 extSubset \n  ::=  TextDecl ?\n extSubsetDecl \n [31]\u00a0 extSubsetDecl \n  ::=  (\n markupdecl  \n|\u00a0 conditionalSect  \n|\u00a0 PEReference  \n|\u00a0 S \n)* \n The external subset and external parameter entities also differ \nfrom the internal subset in that in them,\n parameter-entity references \nare permitted  within  markup declarations,\nnot only  between  markup declarations. \n An example of an XML document with a document type declaration:\n <?xml\u00a0version=\"1.0\"?> <!DOCTYPE\u00a0greeting\u00a0SYSTEM\u00a0\"hello.dtd\"> <greeting>Hello,\u00a0world!</greeting> \nThe  system identifier  \n\" hello.dtd \" gives the URI of a DTD for the document. \n The declarations can also be given locally, as in this \nexample:\n <?xml\u00a0version=\"1.0\"\u00a0encoding=\"UTF-8\"\u00a0?> <!DOCTYPE\u00a0greeting\u00a0[ \u00a0\u00a0<!ELEMENT\u00a0greeting\u00a0(#PCDATA)> ]> <greeting>Hello,\u00a0world!</greeting> \nIf both the external and internal subsets are used, the \ninternal subset is considered to occur before the external subset.\nThis has the effect that entity and attribute-list declarations in the\ninternal subset take precedence over those in the external subset.\n 2.9 Standalone Document Declaration \n Markup declarations can affect the content of the document,\nas passed from an  XML processor  \nto an application; examples are attribute defaults and entity\ndeclarations.\nThe standalone document declaration,\nwhich may appear as a component of the XML declaration, signals\nwhether or not there are such declarations which appear external to \nthe  document entity .\nStandalone Document Declaration \n [32]\u00a0 SDDecl \n  ::=  \n S  \n'standalone'  Eq  \n((\"'\" ('yes' |\u00a0'no') \"'\") |\u00a0('\"' ('yes' |\u00a0'no') '\"'))\n  [  VC:  Standalone Document Declaration  ] \nIn a standalone document declaration, the value \" yes \" indicates\nthat there \nare no markup declarations external to the  document\nentity  (either in the DTD external subset, or in an\nexternal parameter entity referenced from the internal subset)\nwhich affect the information passed from the XML processor to\nthe application.  \nThe value \" no \" indicates that there are or may be such\nexternal markup declarations.\nNote that the standalone document declaration only \ndenotes the presence of external  declarations ; the presence, in a\ndocument, of \nreferences to external  entities , when those entities are\ninternally declared, \ndoes not change its standalone status. \n If there are no external markup declarations, the standalone document\ndeclaration has no meaning. \nIf there are external markup declarations but there is no standalone\ndocument declaration, the value \" no \" is assumed. \n Any XML document for which  standalone=\"no\"  holds can \nbe converted algorithmically to a standalone document, \nwhich may be desirable for some network delivery applications. \n Validity Constraint: \nStandalone Document Declaration \nThe standalone document declaration must have\nthe value \" no \" if any external markup declarations\ncontain declarations of: \n attributes with  default  values, if\nelements to which\nthese attributes apply appear in the document without\nspecifications of values for these attributes, or \n entities (other than  amp ,\n lt ,\n gt ,\n apos ,\n quot ), \nif  references  to those\nentities appear in the document, or\n attributes with values subject to\n normalization , where the\nattribute appears in the document with a value which will\nchange as a result of normalization, or\nelement types with  element content , \nif white space occurs\ndirectly within any instance of those types.\n An example XML declaration with a standalone document declaration: <?xml\u00a0version=\"1.0\"\u00a0standalone='yes'?> \n 2.10 White Space Handling \n In editing XML documents, it is often convenient to use \"white space\"\n(spaces, tabs, and blank lines, denoted by the nonterminal \n S  in this specification) to\nset apart the markup for greater readability.  Such white space is typically\nnot intended for inclusion in the delivered version of the document.\nOn the other hand, \"significant\" white space that should be preserved in the\ndelivered version is common, for example in poetry and\nsource code. \n An  XML processor  \nmust always pass all characters in a document that are not\nmarkup through to the application.   A  \nvalidating XML processor  must also inform the application\nwhich  of these characters constitute white space appearing\nin  element content .\n A special  attribute  \nnamed  xml:space  may be attached to an element\nto signal an intention that in that element,\nwhite space should be preserved by applications.\nIn valid documents, this attribute, like any other, must be \n declared  if it is used.\nWhen declared, it must be given as an \n enumerated type  whose only\npossible values are \" default \" and \" preserve \".\nFor example: \u00a0\u00a0\u00a0\u00a0<!ATTLIST\u00a0poem\u00a0\u00a0\u00a0xml:space\u00a0(default|preserve)\u00a0'preserve'> \n The value \" default \" signals that applications'\ndefault white-space processing modes are acceptable for this element; the\nvalue \" preserve \" indicates the intent that applications preserve\nall the white space.\nThis declared intent is considered to apply to all elements within the content\nof the element where it is specified, unless overriden with another instance\nof the  xml:space  attribute.\n The  root element  of any document\nis considered to have signaled no intentions as regards application space\nhandling, unless it provides a value for \nthis attribute or the attribute is declared with a default value.\n 2.11 End-of-Line Handling \n XML  parsed entities  are often stored in\ncomputer files which, for editing convenience, are organized into lines.\nThese lines are typically separated by some combination of the characters\ncarriage-return (#xD) and line-feed (#xA). \n To simplify the tasks of  applications ,\nwherever an external parsed entity or the literal entity value\nof an internal parsed entity contains either the literal \ntwo-character sequence \"#xD#xA\" or a standalone literal\n#xD, an  XML processor  must \npass to the application the single character #xA.\n(This behavior can \nconveniently be produced by normalizing all \nline breaks to #xA on input, before parsing.)\n 2.12 Language Identification \n In document processing, it is often useful to\nidentify the natural or formal language \nin which the content is \nwritten.\nA special  attribute  named\n xml:lang  may be inserted in\ndocuments to specify the \nlanguage used in the contents and attribute values \nof any element in an XML document.\nIn valid documents, this attribute, like any other, must be \n declared  if it is used.\nThe values of the attribute are language identifiers as defined\nby  [IETF RFC 1766] , \"Tags for the Identification of Languages\":\nLanguage Identification \n [33]\u00a0 LanguageID \n  ::=  Langcode  \n('-'  Subcode )* \n [34]\u00a0 Langcode \n  ::=  ISO639Code  |\u00a0\n IanaCode  |\u00a0\n UserCode \n [35]\u00a0 ISO639Code \n  ::=  ([a-z] |\u00a0[A-Z]) ([a-z] |\u00a0[A-Z]) \n [36]\u00a0 IanaCode \n  ::=  ('i' |\u00a0'I') '-' ([a-z] |\u00a0[A-Z])+ \n [37]\u00a0 UserCode \n  ::=  ('x' |\u00a0'X') '-' ([a-z] |\u00a0[A-Z])+ \n [38]\u00a0 Subcode \n  ::=  ([a-z] |\u00a0[A-Z])+ \nThe  Langcode  may be any of the following:\n a two-letter language code as defined by \n [ISO 639] , \"Codes\nfor the representation of names of languages\" \n a language identifier registered with the Internet\nAssigned Numbers Authority  [IANA] ; these begin with the \nprefix \" i- \" (or \" I- \") \n a language identifier assigned by the user, or agreed on\nbetween parties in private use; these must begin with the\nprefix \" x- \" or \" X- \" in order to ensure that they do not conflict \nwith names later standardized or registered with IANA \n There may be any number of  Subcode  segments; if\nthe first \nsubcode segment exists and the Subcode consists of two \nletters, then it must be a country code from \n [ISO 3166] , \"Codes \nfor the representation of names of countries.\"\nIf the first \nsubcode consists of more than two letters, it must be\na subcode for the language in question registered with IANA,\nunless the  Langcode  begins with the prefix \n\" x- \" or\n\" X- \".  \n It is customary to give the language code in lower case, and\nthe country code (if any) in upper case.\nNote that these values, unlike other names in XML documents,\nare case insensitive. \n For example:\n <p\u00a0xml:lang=\"en\">The\u00a0quick\u00a0brown\u00a0fox\u00a0jumps\u00a0over\u00a0the\u00a0lazy\u00a0dog.</p> <p\u00a0xml:lang=\"en-GB\">What\u00a0colour\u00a0is\u00a0it?</p> <p\u00a0xml:lang=\"en-US\">What\u00a0color\u00a0is\u00a0it?</p> <sp\u00a0who=\"Faust\"\u00a0desc='leise'\u00a0xml:lang=\"de\"> \u00a0\u00a0<l>Habe\u00a0nun,\u00a0ach!\u00a0Philosophie,</l> \u00a0\u00a0<l>Juristerei,\u00a0und\u00a0Medizin</l> \u00a0\u00a0<l>und\u00a0leider\u00a0auch\u00a0Theologie</l> \u00a0\u00a0<l>durchaus\u00a0studiert\u00a0mit\u00a0hei\u00dfem\u00a0Bem\u00fch'n.</l> \u00a0\u00a0</sp> \n The intent declared with  xml:lang  is considered to apply to\nall attributes and content of the element where it is specified,\nunless overridden with an instance of  xml:lang \non another element within that content. \n A simple declaration for  xml:lang  might take\nthe form\n xml:lang\u00a0\u00a0NMTOKEN\u00a0\u00a0#IMPLIED \nbut specific default values may also be given, if appropriate.  In a\ncollection of French poems for English students, with glosses and\nnotes in English, the xml:lang attribute might be declared this way:\n \u00a0\u00a0\u00a0\u00a0<!ATTLIST\u00a0poem\u00a0\u00a0\u00a0xml:lang\u00a0NMTOKEN\u00a0'fr'> \u00a0\u00a0\u00a0\u00a0<!ATTLIST\u00a0gloss\u00a0\u00a0xml:lang\u00a0NMTOKEN\u00a0'en'> \u00a0\u00a0\u00a0\u00a0<!ATTLIST\u00a0note\u00a0\u00a0\u00a0xml:lang\u00a0NMTOKEN\u00a0'en'> \n 3. Logical Structures \n Each  XML document  contains one or more\n elements , the boundaries of which are \neither delimited by  start-tags  \nand  end-tags , or, for  empty  elements, by an  empty-element tag . Each element has a type,\nidentified by name, sometimes called its \"generic\nidentifier\" (GI), and may have a set of\nattribute specifications.  Each attribute specification \nhas a  name  and a  value .\n Element \n [39]\u00a0 element \n  ::=  EmptyElemTag \n |\u00a0 STag   content \n ETag \n  [  WFC:  Element Type Match  ] \n  [  VC:  Element Valid  ] \n This specification does not constrain the semantics, use, or (beyond\nsyntax) names of the element types and attributes, except that names\nbeginning with a match to  (('X'|'x')('M'|'m')('L'|'l')) \nare reserved for standardization in this or future versions of this\nspecification.\n Well-Formedness Constraint: \nElement Type Match \nThe  Name  in an element's end-tag must match \nthe element type in\nthe start-tag.\n Validity Constraint: \nElement Valid \nAn element is\nvalid if\nthere is a declaration matching \n elementdecl  where the\n Name  matches the element type, and\none of the following holds:\n The declaration matches  EMPTY  and the element has no \n content . \n The declaration matches  children  and\nthe sequence of \n child elements \nbelongs to the language generated by the regular expression in\nthe content model, with optional white space (characters \nmatching the nonterminal  S ) between each pair\nof child elements. \n The declaration matches  Mixed  and \nthe content consists of  character \ndata  and  child elements \nwhose types match names in the content model. \n The declaration matches  ANY , and the types\nof any  child elements  have\nbeen declared. \n 3.1 Start-Tags, End-Tags, and Empty-Element Tags \n The beginning of every\nnon-empty XML element is marked by a  start-tag .\nStart-tag \n [40]\u00a0 STag \n  ::=  '<'  Name  \n( S   Attribute )* \n S ? '>' \n  [  WFC:  Unique Att Spec  ] \n [41]\u00a0 Attribute \n  ::=  Name   Eq \n AttValue \n  [  VC:  Attribute Value Type  ] \n  [  WFC:  No External Entity References  ] \n  [  WFC:  No < in Attribute Values  ] \nThe  Name  in\nthe start- and end-tags gives the \nelement's  type .\nThe  Name - AttValue  pairs are\nreferred to as \nthe  attribute specifications  of the element,\n with the \n Name  in each pair\nreferred to as the  attribute name  and\n the content of the\n AttValue  (the text between the\n '  or  \"  delimiters)\nas the  attribute value .\n Well-Formedness Constraint: \nUnique Att Spec \nNo attribute name may appear more than once in the same start-tag\nor empty-element tag.\n Validity Constraint: \nAttribute Value Type \nThe attribute must have been declared; the value must be of the type \ndeclared for it.\n(For attribute types, see \" 3.3\u00a0Attribute-List Declarations \".)\n Well-Formedness Constraint: \nNo External Entity References \nAttribute values cannot contain direct or indirect entity references \nto external entities.\n Well-Formedness Constraint: \nNo  <  in Attribute Values \nThe  replacement text  of any entity\nreferred to directly or indirectly in an attribute\nvalue (other than \" &lt; \") must not contain\na  < .\n An example of a start-tag:\n <termdef\u00a0id=\"dt-dog\"\u00a0term=\"dog\"> \n The end of every element \nthat begins with a start-tag must\nbe marked by an  end-tag \ncontaining a name that echoes the element's type as given in the\nstart-tag:\nEnd-tag \n [42]\u00a0 ETag \n  ::=  '</'  Name \n S ? '>' \n An example of an end-tag: </termdef> \n The \n text  between the start-tag and\nend-tag is called the element's\n content :\nContent of Elements \n [43]\u00a0 content \n  ::=  ( element  |\u00a0 CharData  \n|\u00a0 Reference  |\u00a0 CDSect  \n|\u00a0 PI  |\u00a0 Comment )* \n If an element is  empty ,\nit must be represented either by a start-tag immediately followed\nby an end-tag or by an empty-element tag.\n An \n empty-element tag  takes a special form:\nTags for Empty Elements \n [44]\u00a0 EmptyElemTag \n  ::=  '<'  Name  ( S \n Attribute )*  S ? \n'/>' \n  [  WFC:  Unique Att Spec  ] \n Empty-element tags may be used for any element which has no\ncontent, whether or not it is declared using the keyword\n EMPTY .\n For interoperability , the empty-element\ntag must be used, and can only be used, for elements which are\n declared   EMPTY . \n Examples of empty elements:\n <IMG\u00a0align=\"left\" \u00a0src=\"http://www.w3.org/Icons/WWW/w3c_home\"\u00a0/> <br></br> <br/> \n 3.2 Element Type Declarations \n The  element  structure of an\n XML document  may, for \n validation  purposes, \nbe constrained\nusing element type and attribute-list declarations.\nAn element type declaration constrains the element's\n content .\n Element type declarations often constrain which element types can\nappear as  children  of the element.\nAt user option, an XML processor may issue a warning\nwhen a declaration mentions an element type for which no declaration\nis provided, but this is not an error. \n An  element\ntype declaration  takes the form:\nElement Type Declaration \n [45]\u00a0 elementdecl \n  ::=  '<!ELEMENT'  S \n Name \n S \n contentspec \n S ? '>' \n  [  VC:  Unique Element Type Declaration  ] \n [46]\u00a0 contentspec \n  ::=  'EMPTY' \n|\u00a0'ANY' \n|\u00a0 Mixed  \n|\u00a0 children \nwhere the  Name  gives the element type \nbeing declared.\n Validity Constraint: \nUnique Element Type Declaration \nNo element type may be declared more than once.\n Examples of element type declarations:\n <!ELEMENT\u00a0br\u00a0EMPTY> <!ELEMENT\u00a0p\u00a0(#PCDATA|emph)*\u00a0> <!ELEMENT\u00a0%name.para;\u00a0%content.para;\u00a0> <!ELEMENT\u00a0container\u00a0ANY> \n 3.2.1 Element Content \n An element  type  has\n element content  when elements of that\ntype must contain only  child  \nelements (no character data), optionally separated by \nwhite space (characters matching the nonterminal \n S ).\nIn this case, the\nconstraint includes a content model, a simple grammar governing\nthe allowed types of the child\nelements and the order in which they are allowed to appear.  \nThe grammar is built on\ncontent particles ( cp s), which consist of names, \nchoice lists of content particles, or\nsequence lists of content particles:\nElement-content Models \n [47]\u00a0 children \n  ::=  ( choice  \n|\u00a0 seq ) \n('?' |\u00a0'*' |\u00a0'+')? \n [48]\u00a0 cp \n  ::=  ( Name  \n|\u00a0 choice  \n|\u00a0 seq ) \n('?' |\u00a0'*' |\u00a0'+')? \n [49]\u00a0 choice \n  ::=  '('  S ? cp \n(  S ? '|'  S ?  cp  )*\n S ? ')' \n  [  VC:  Proper Group/PE Nesting  ] \n [50]\u00a0 seq \n  ::=  '('  S ? cp \n(  S ? ','  S ?  cp  )*\n S ? ')' \n  [  VC:  Proper Group/PE Nesting  ] \nwhere each  Name  is the type of an element which may\nappear as a  child .  \nAny content\nparticle in a choice list may appear in the  element content  at the location where\nthe choice list appears in the grammar;\ncontent particles occurring in a sequence list must each\nappear in the  element content  in the\norder given in the list.  \nThe optional character following a name or list governs\nwhether the element or the content particles in the list may occur one\nor more ( + ), zero or more ( * ), or zero or \none times ( ? ).  \nThe absence of such an operator means that the element or content particle\nmust appear exactly once.\nThis syntax\nand meaning are identical to those used in the productions in this\nspecification. \nThe content of an element matches a content model if and only if it is\npossible to trace out a path through the content model, obeying the\nsequence, choice, and repetition operators and matching each element in\nthe content against an element type in the content model.   For compatibility , it is an error\nif an element in the document can\nmatch more than one occurrence of an element type in the content model.\nFor more information, see \" E.\u00a0Deterministic Content Models \".\n Validity Constraint: \nProper Group/PE Nesting \nParameter-entity \n replacement text  must be properly nested\nwith parenthetized groups.\nThat is to say, if either of the opening or closing parentheses\nin a  choice ,  seq , or\n Mixed  construct \nis contained in the replacement text for a \n parameter entity ,\nboth must be contained in the same replacement text.\n For interoperability , \nif a parameter-entity reference appears in a \n choice ,  seq , or\n Mixed  construct, its replacement text\nshould not be empty, and \nneither the first nor last non-blank\ncharacter of the replacement text should be a connector \n( |  or  , ).\n Examples of element-content models:\n <!ELEMENT\u00a0spec\u00a0(front,\u00a0body,\u00a0back?)> <!ELEMENT\u00a0div1\u00a0(head,\u00a0(p\u00a0|\u00a0list\u00a0|\u00a0note)*,\u00a0div2*)> <!ELEMENT\u00a0dictionary-body\u00a0(%div.mix;\u00a0|\u00a0%dict.mix;)*> \n 3.2.2 Mixed Content \n An element \n type  has \n mixed content  when elements of that type may contain\ncharacter data, optionally interspersed with\n child  elements.\nIn this case, the types of the child elements\nmay be constrained, but not their order or their number of occurrences:\nMixed-content Declaration \n [51]\u00a0 Mixed \n  ::=  '('  S ? \n'#PCDATA'\n( S ? \n'|' \n S ? \n Name )* \n S ? \n')*'  \n |\u00a0'('  S ? '#PCDATA'  S ? ')'\n  [  VC:  Proper Group/PE Nesting  ] \n  [  VC:  No Duplicate Types  ] \nwhere the  Name s give the types of elements\nthat may appear as children.\n Validity Constraint: \nNo Duplicate Types \nThe same name must not appear more than once in a single mixed-content\ndeclaration.\n Examples of mixed content declarations:\n <!ELEMENT\u00a0p\u00a0(#PCDATA|a|ul|b|i|em)*> <!ELEMENT\u00a0p\u00a0(#PCDATA\u00a0|\u00a0%font;\u00a0|\u00a0%phrase;\u00a0|\u00a0%special;\u00a0|\u00a0%form;)*\u00a0> <!ELEMENT\u00a0b\u00a0(#PCDATA)> \n 3.3 Attribute-List Declarations \n Attributes  are used to associate\nname-value pairs with  elements .\nAttribute specifications may appear only within  start-tags \nand  empty-element tags ; \nthus, the productions used to\nrecognize them appear in \" 3.1\u00a0Start-Tags, End-Tags, and Empty-Element Tags \".  \nAttribute-list\ndeclarations may be used:\n To define the set of attributes pertaining to a given\nelement type. \n To establish type constraints for these\nattributes. \n To provide  default values \nfor attributes. \n Attribute-list declarations  specify the name, data type, and default\nvalue (if any) of each attribute associated with a given element type:\nAttribute-list Declaration \n [52]\u00a0 AttlistDecl \n  ::=  '<!ATTLIST'  S \n Name \n AttDef *\n S ? '>' \n [53]\u00a0 AttDef \n  ::=  S   Name \n S   AttType \n S   DefaultDecl \nThe  Name  in the\n AttlistDecl  rule is the type of an element.  At\nuser option, an XML processor may issue a warning if attributes are\ndeclared for an element type not itself declared, but this is not an\nerror.  The  Name  in the \n AttDef  rule is\nthe name of the attribute. \nWhen more than one  AttlistDecl  is provided for a\ngiven element type, the contents of all those provided are merged.  When\nmore than one definition is provided for the same attribute of a\ngiven element type, the first declaration is binding and later\ndeclarations are ignored.  \n For interoperability,  writers of DTDs\nmay choose to provide at most one attribute-list declaration\nfor a given element type, at most one attribute definition\nfor a given attribute name, and at least one attribute definition\nin each attribute-list declaration.\nFor interoperability, an XML processor may at user option\nissue a warning when more than one attribute-list declaration is\nprovided for a given element type, or more than one attribute definition\nis provided \nfor a given attribute, but this is not an error.\n 3.3.1 Attribute Types \n XML attribute types are of three kinds:  a string type, a\nset of tokenized types, and enumerated types.  The string type may take\nany literal string as a value; the tokenized types have varying lexical\nand semantic constraints, as noted:\nAttribute Types \n [54]\u00a0 AttType \n  ::=  StringType  \n|\u00a0 TokenizedType  \n|\u00a0 EnumeratedType \n [55]\u00a0 StringType \n  ::=  'CDATA' \n [56]\u00a0 TokenizedType \n  ::=  'ID' \n  [  VC:  ID  ] \n  [  VC:  One ID per Element Type  ] \n  [  VC:  ID Attribute Default  ] \n |\u00a0'IDREF' \n  [  VC:  IDREF  ] \n |\u00a0'IDREFS' \n  [  VC:  IDREF  ] \n |\u00a0'ENTITY' \n  [  VC:  Entity Name  ] \n |\u00a0'ENTITIES' \n  [  VC:  Entity Name  ] \n |\u00a0'NMTOKEN' \n  [  VC:  Name Token  ] \n |\u00a0'NMTOKENS' \n  [  VC:  Name Token  ] \n Validity Constraint: \nID \nValues of type  ID  must match the \n Name  production.  \nA name must not appear more than once in\nan XML document as a value of this type; i.e., ID values must uniquely\nidentify the elements which bear them.   \n Validity Constraint: \nOne ID per Element Type \nNo element type may have more than one ID attribute specified.\n Validity Constraint: \nID Attribute Default \nAn ID attribute must have a declared default of  #IMPLIED  or\n #REQUIRED .\n Validity Constraint: \nIDREF \nValues of type  IDREF  must match\nthe  Name  production, and\nvalues of type  IDREFS  must match\n Names ; \neach  Name  must match the value of an ID attribute on \nsome element in the XML document; i.e.  IDREF  values must \nmatch the value of some ID attribute. \n Validity Constraint: \nEntity Name \nValues of type  ENTITY  \nmust match the  Name  production,\nvalues of type  ENTITIES  must match\n Names ;\neach  Name  must \nmatch the\nname of an  unparsed entity  declared in the\n DTD .\n Validity Constraint: \nName Token \nValues of type  NMTOKEN  must match the\n Nmtoken  production;\nvalues of type  NMTOKENS  must \nmatch  Nmtokens .\n Enumerated attributes  can take one \nof a list of values provided in the declaration. There are two\nkinds of enumerated types:\nEnumerated Attribute Types \n [57]\u00a0 EnumeratedType \n  ::=  NotationType  \n|\u00a0 Enumeration \n [58]\u00a0 NotationType \n  ::=  'NOTATION' \n S  \n'(' \n S ?  \n Name  \n( S ? '|'  S ?  \n Name )*\n S ? ')'\n  [  VC:  Notation Attributes  ] \n [59]\u00a0 Enumeration \n  ::=  '('  S ?\n Nmtoken  \n( S ? '|' \n S ?  \n Nmtoken )* \n S ? \n')' \n  [  VC:  Enumeration  ] \nA  NOTATION  attribute identifies a \n notation , declared in the \nDTD with associated system and/or public identifiers, to\nbe used in interpreting the element to which the attribute\nis attached.\n Validity Constraint: \nNotation Attributes \nValues of this type must match\none of the  notation  names included in\nthe declaration; all notation names in the declaration must\nbe declared.\n Validity Constraint: \nEnumeration \nValues of this type\nmust match one of the  Nmtoken  tokens in the\ndeclaration. \n For interoperability,  the same\n Nmtoken  should not occur more than once in the\nenumerated attribute types of a single element type.\n 3.3.2 Attribute Defaults \n An  attribute declaration  provides\ninformation on whether\nthe attribute's presence is required, and if not, how an XML processor should\nreact if a declared attribute is absent in a document.\nAttribute Defaults \n [60]\u00a0 DefaultDecl \n  ::=  '#REQUIRED' \n|\u00a0'#IMPLIED'  \n |\u00a0(('#FIXED' S)?  AttValue ) \n  [  VC:  Required Attribute  ] \n  [  VC:  Attribute Default Legal  ] \n  [  WFC:  No < in Attribute Values  ] \n  [  VC:  Fixed Attribute Default  ] \n In an attribute declaration,  #REQUIRED  means that the\nattribute must always be provided,  #IMPLIED  that no default \nvalue is provided.\n If the \ndeclaration\nis neither  #REQUIRED  nor  #IMPLIED , then the\n AttValue  value contains the declared\n default  value; the  #FIXED  keyword states that\nthe attribute must always have the default value.\nIf a default value\nis declared, when an XML processor encounters an omitted attribute, it\nis to behave as though the attribute were present with \nthe declared default value. \n Validity Constraint: \nRequired Attribute \nIf the default declaration is the keyword  #REQUIRED , then\nthe attribute must be specified for\nall elements of the type in the attribute-list declaration.\n Validity Constraint: \nAttribute Default Legal \nThe declared\ndefault value must meet the lexical constraints of the declared attribute type.\n Validity Constraint: \nFixed Attribute Default \nIf an attribute has a default value declared with the \n #FIXED  keyword, instances of that attribute must\nmatch the default value.\n Examples of attribute-list declarations:\n <!ATTLIST\u00a0termdef \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0id\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ID\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#REQUIRED \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0name\u00a0\u00a0\u00a0\u00a0CDATA\u00a0\u00a0\u00a0#IMPLIED> <!ATTLIST\u00a0list \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0type\u00a0\u00a0\u00a0\u00a0(bullets|ordered|glossary)\u00a0\u00a0\"ordered\"> <!ATTLIST\u00a0form \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0method\u00a0\u00a0CDATA\u00a0\u00a0\u00a0#FIXED\u00a0\"POST\"> \n 3.3.3 Attribute-Value Normalization \n Before the value of an attribute is passed to the application\nor checked for validity, the\nXML processor must normalize it as follows:\n a character reference is processed by appending the referenced    \ncharacter to the attribute value \n an entity reference is processed by recursively processing the\nreplacement text of the entity \n a whitespace character (#x20, #xD, #xA, #x9) is processed by\nappending #x20 to the normalized value, except that only a single #x20\nis appended for a \"#xD#xA\" sequence that is part of an external\nparsed entity or the literal entity value of an internal parsed\nentity \n other characters are processed by appending them to the normalized\nvalue\n If the declared value is not CDATA, then the XML processor must\nfurther process the normalized attribute value by discarding any\nleading and trailing space (#x20) characters, and by replacing\nsequences of space (#x20) characters by a single space (#x20)\ncharacter. \nAll attributes for which no declaration has been read should be treated\nby a non-validating parser as if declared\n CDATA .\n 3.4 Conditional Sections \n Conditional sections  are portions of the\n document type declaration external subset \nwhich are \nincluded in, or excluded from, the logical structure of the DTD based on\nthe keyword which governs them.\nConditional Section \n [61]\u00a0 conditionalSect \n  ::=  includeSect \n|\u00a0 ignoreSect \n [62]\u00a0 includeSect \n  ::=  '<![' S? 'INCLUDE' S? '[' \n extSubsetDecl \n']]>'\n [63]\u00a0 ignoreSect \n  ::=  '<![' S? 'IGNORE' S? '[' \n ignoreSectContents *\n']]>' \n [64]\u00a0 ignoreSectContents \n  ::=  Ignore \n('<!['  ignoreSectContents  ']]>' \n Ignore )* \n [65]\u00a0 Ignore \n  ::=  Char * - \n( Char * ('<![' |\u00a0']]>') \n Char *)\n Like the internal and external DTD subsets, a conditional section\nmay contain one or more complete declarations,\ncomments, processing instructions, \nor nested conditional sections, intermingled with white space.\n If the keyword of the\nconditional section is  INCLUDE , then the contents of the conditional\nsection are part of the DTD.\nIf the keyword of the conditional\nsection is  IGNORE , then the contents of the conditional section are\nnot logically part of the DTD.\nNote that for reliable parsing, the contents of even ignored\nconditional sections must be read in order to\ndetect nested conditional sections and ensure that the end of the\noutermost (ignored) conditional section is properly detected.\nIf a conditional section with a\nkeyword of  INCLUDE  occurs within a larger conditional\nsection with a keyword of  IGNORE , both the outer and the\ninner conditional sections are ignored. \n If the keyword of the conditional section is a \nparameter-entity reference, the parameter entity must be replaced by its\ncontent before the processor decides whether to\ninclude or ignore the conditional section. \n An example:\n <!ENTITY\u00a0%\u00a0draft\u00a0'INCLUDE'\u00a0> <!ENTITY\u00a0%\u00a0final\u00a0'IGNORE'\u00a0> \u00a0 <![%draft;[ <!ELEMENT\u00a0book\u00a0(comments*,\u00a0title,\u00a0body,\u00a0supplements?)> ]]> <![%final;[ <!ELEMENT\u00a0book\u00a0(title,\u00a0body,\u00a0supplements?)> ]]> \n 4. Physical Structures \n An XML document may consist\nof one or many storage units.   These are called\n entities ; they all have  content  and are all\n(except for the document entity, see below, and \nthe  external DTD subset ) \nidentified by  name .\nEach XML document has one entity\ncalled the  document entity , which serves\nas the starting point for the  XML\nprocessor  and may contain the whole document. \n Entities may be either parsed or unparsed.\n A  parsed entity's \ncontents are referred to as its \n replacement text ;\nthis  text  is considered an\nintegral part of the document. \n An \n unparsed entity  \nis a resource whose contents may or may not be\n text , and if text, may not be XML.\nEach unparsed entity\nhas an associated  notation , identified by name.\nBeyond a requirement\nthat an XML processor make the identifiers for the entity and \nnotation available to the application,\nXML places no constraints on the contents of unparsed entities. \nParsed entities are invoked by name using entity references;\nunparsed entities by name, given in the value of  ENTITY \nor  ENTITIES \nattributes. \n General entities \nare entities for use within the document content.\nIn this specification, general entities are sometimes referred \nto with the unqualified term  entity  when this leads\nto no ambiguity. \n Parameter entities \nare parsed entities for use within the DTD.\nThese two types of entities use different forms of reference and\nare recognized in different contexts.\nFurthermore, they occupy different namespaces; a parameter entity and\na general entity with the same name are two distinct entities.\n 4.1 Character and Entity References \nA  character reference  refers to a specific character in the\nISO/IEC 10646 character set, for example one not directly accessible from\navailable input devices.\nCharacter Reference \n [66]\u00a0 CharRef \n  ::=  '&#' [0-9]+ ';'  \n |\u00a0'&#x' [0-9a-fA-F]+ ';' \n  [  WFC:  Legal Character  ] \n Well-Formedness Constraint: \nLegal Character \nCharacters referred to using character references must\nmatch the production for\n Char .\nIf the character reference begins with \" &#x \", the digits and\nletters up to the terminating  ;  provide a hexadecimal\nrepresentation of the character's code point in ISO/IEC 10646.\nIf it begins just with \" &# \", the digits up to the terminating\n ;  provide a decimal representation of the character's \ncode point.\n An  entity\nreference  refers to the content of a named entity.\n References to \nparsed general entities\nuse ampersand ( & ) and semicolon ( ; ) as\ndelimiters.\n Parameter-entity references  use percent-sign ( % ) and\nsemicolon \n( ; ) as delimiters.\nEntity Reference \n [67]\u00a0 Reference \n  ::=  EntityRef  \n|\u00a0 CharRef \n [68]\u00a0 EntityRef \n  ::=  '&'  Name  ';' \n  [  WFC:  Entity Declared  ] \n  [  VC:  Entity Declared  ] \n  [  WFC:  Parsed Entity  ] \n  [  WFC:  No Recursion  ] \n [69]\u00a0 PEReference \n  ::=  '%'  Name  ';' \n  [  VC:  Entity Declared  ] \n  [  WFC:  No Recursion  ] \n  [  WFC:  In DTD  ] \n Well-Formedness Constraint: \nEntity Declared \nIn a document without any DTD, a document with only an internal\nDTD subset which contains no parameter entity references, or a document with\n\" standalone='yes' \", \nthe  Name  given in the entity reference must \n match  that in an \n entity declaration , except that\nwell-formed documents need not declare \nany of the following entities:  amp ,\n lt ,\n gt ,\n apos ,\n quot .  \nThe declaration of a parameter entity must precede any reference to it.\nSimilarly, the declaration of a general entity must precede any\nreference to it which appears in a default value in an attribute-list\ndeclaration.\nNote that if entities are declared in the external subset or in \nexternal parameter entities, a non-validating processor is \n not obligated to  read\nand process their declarations; for such documents, the rule that\nan entity must be declared is a well-formedness constraint only\nif  standalone='yes' .\n Validity Constraint: \nEntity Declared \nIn a document with an external subset or external parameter\nentities with \" standalone='no' \",\nthe  Name  given in the entity reference must  match  that in an \n entity declaration .\nFor interoperability, valid documents should declare the entities \n amp ,\n lt ,\n gt ,\n apos ,\n quot , in the form\nspecified in \" 4.6\u00a0Predefined Entities \".\nThe declaration of a parameter entity must precede any reference to it.\nSimilarly, the declaration of a general entity must precede any\nreference to it which appears in a default value in an attribute-list\ndeclaration.\n Well-Formedness Constraint: \nParsed Entity \nAn entity reference must not contain the name of an  unparsed entity . Unparsed entities may be referred\nto only in  attribute values  declared to\nbe of type  ENTITY  or  ENTITIES .\n Well-Formedness Constraint: \nNo Recursion \nA parsed entity must not contain a recursive reference to itself,\neither directly or indirectly.\n Well-Formedness Constraint: \nIn DTD \nParameter-entity references may only appear in the \n DTD .\n Examples of character and entity references:\n Type\u00a0<key>less-than</key>\u00a0(&#x3C;)\u00a0to\u00a0save\u00a0options. This\u00a0document\u00a0was\u00a0prepared\u00a0on\u00a0&docdate;\u00a0and is\u00a0classified\u00a0&security-level;. \n Example of a parameter-entity reference:\n <!--\u00a0declare\u00a0the\u00a0parameter\u00a0entity\u00a0\"ISOLat2\"...\u00a0--> <!ENTITY\u00a0%\u00a0ISOLat2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SYSTEM\u00a0\"http://www.xml.com/iso/isolat2-xml.entities\"\u00a0> <!--\u00a0...\u00a0now\u00a0reference\u00a0it.\u00a0--> %ISOLat2; \n 4.2 Entity Declarations \nEntities are declared thus:\nEntity Declaration \n [70]\u00a0 EntityDecl \n  ::=  GEDecl  |\u00a0 PEDecl \n [71]\u00a0 GEDecl \n  ::=  '<!ENTITY'  S   Name \n S   EntityDef \n S ? '>' \n [72]\u00a0 PEDecl \n  ::=  '<!ENTITY'  S  '%'  S \n Name   S \n PEDef   S ? '>' \n [73]\u00a0 EntityDef \n  ::=  EntityValue \n|\u00a0( ExternalID \n NDataDecl ?) \n [74]\u00a0 PEDef \n  ::=  EntityValue  \n|\u00a0 ExternalID \nThe  Name  identifies the entity in an\n entity reference  or, in the case of an\nunparsed entity, in the value of an  ENTITY  or  ENTITIES \nattribute.\nIf the same entity is declared more than once, the first declaration\nencountered is binding; at user option, an XML processor may issue a\nwarning if entities are declared multiple times.\n 4.2.1 Internal Entities \n If \nthe entity definition is an \n EntityValue ,  \nthe defined entity is called an  internal entity .  \nThere is no separate physical\nstorage object, and the content of the entity is given in the\ndeclaration. \nNote that some processing of entity and character references in the\n literal entity value  may be required to\nproduce the correct  replacement \ntext : see \" 4.5\u00a0Construction of Internal Entity Replacement Text \".\n An internal entity is a  parsed\nentity . \n Example of an internal entity declaration:\n <!ENTITY\u00a0Pub-Status\u00a0\"This\u00a0is\u00a0a\u00a0pre-release\u00a0of\u00a0the \u00a0specification.\"> \n 4.2.2 External Entities \n If the entity is not\ninternal, it is an  external\nentity , declared as follows:\nExternal Entity Declaration \n [75]\u00a0 ExternalID \n  ::=  'SYSTEM'  S \n SystemLiteral \n |\u00a0'PUBLIC'  S \n PubidLiteral \n S \n SystemLiteral \n [76]\u00a0 NDataDecl \n  ::=  S  'NDATA'  S \n Name \n  [  VC:  Notation Declared  ] \nIf the  NDataDecl  is present, this is a\ngeneral  unparsed\nentity ; otherwise it is a parsed entity. \n Validity Constraint: \nNotation Declared \nThe  Name  must match the declared name of a\n notation .\n The\n SystemLiteral  \nis called the entity's  system identifier . It is a URI,\nwhich may be used to retrieve the entity.\nNote that the hash mark ( # ) and fragment identifier \nfrequently used with URIs are not, formally, part of the URI itself; \nan XML processor may signal an error if a fragment identifier is \ngiven as part of a system identifier.\nUnless otherwise provided by information outside the scope of this\nspecification (e.g. a special XML element type defined by a particular\nDTD, or a processing instruction defined by a particular application\nspecification), relative URIs are relative to the location of the\nresource within which the entity declaration occurs.\nA URI might thus be relative to the \n document entity , to the entity\ncontaining the  external DTD subset , \nor to some other  external parameter entity .\n An XML processor should handle a non-ASCII character in a URI by\nrepresenting the character in UTF-8 as one or more bytes, and then \nescaping these bytes with the URI escaping mechanism (i.e., by\nconverting each byte to %HH, where HH is the hexadecimal notation of the\nbyte value). \nIn addition to a system identifier, an external identifier may\ninclude a  public identifier .  \nAn XML processor attempting to retrieve the entity's content may use the public\nidentifier to try to generate an alternative URI.  If the processor\nis unable to do so, it must use the URI specified in the system\nliteral.  Before a match is attempted, all strings\nof white space in the public identifier must be normalized to single space characters (#x20),\nand leading and trailing white space must be removed. \n Examples of external entity declarations:\n <!ENTITY\u00a0open-hatch \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SYSTEM\u00a0\"http://www.textuality.com/boilerplate/OpenHatch.xml\"> <!ENTITY\u00a0open-hatch \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PUBLIC\u00a0\"-//Textuality//TEXT\u00a0Standard\u00a0open-hatch\u00a0boilerplate//EN\" \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"http://www.textuality.com/boilerplate/OpenHatch.xml\"> <!ENTITY\u00a0hatch-pic \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SYSTEM\u00a0\"../grafix/OpenHatch.gif\" \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NDATA\u00a0gif\u00a0> \n 4.3 Parsed Entities \n 4.3.1 The Text Declaration \n External parsed entities may each begin with a  text\ndeclaration . \nText Declaration \n [77]\u00a0 TextDecl \n  ::=  '<?xml' \n VersionInfo ?\n EncodingDecl \n S ? '?>' \n The text declaration must be provided literally, not\nby reference to a parsed entity.\nNo text declaration may appear at any position other than the beginning of\nan external parsed entity. \n 4.3.2 Well-Formed Parsed Entities \n The document entity is well-formed if it matches the production labeled\n document .\nAn external general \nparsed entity is well-formed if it matches the production labeled\n extParsedEnt .\nAn external parameter\nentity is well-formed if it matches the production labeled\n extPE .\nWell-Formed External Parsed Entity \n [78]\u00a0 extParsedEnt \n  ::=  TextDecl ? \n content \n [79]\u00a0 extPE \n  ::=  TextDecl ? \n extSubsetDecl \nAn internal general parsed entity is well-formed if its replacement text \nmatches the production labeled\n content .\nAll internal parameter entities are well-formed by definition.\n A consequence of well-formedness in entities is that the logical \nand physical structures in an XML document are properly nested; no \n start-tag ,\n end-tag ,\n empty-element tag ,\n element , \n comment , \n processing instruction , \n character\nreference , or\n entity reference  \ncan begin in one entity and end in another. \n 4.3.3 Character Encoding in Entities \n Each external parsed entity in an XML document may use a different\nencoding for its characters. All XML processors must be able to read\nentities in either UTF-8 or UTF-16. \n Entities encoded in UTF-16 must\nbegin with the Byte Order Mark described by ISO/IEC 10646 Annex E and\nUnicode Appendix B (the ZERO WIDTH NO-BREAK SPACE character, #xFEFF).\nThis is an encoding signature, not part of either the markup or the\ncharacter data of the XML document.\nXML processors must be able to use this character to\ndifferentiate between UTF-8 and UTF-16 encoded documents. \n Although an XML processor is required to read only entities in\nthe UTF-8 and UTF-16 encodings, it is recognized that other encodings are\nused around the world, and it may be desired for XML processors\nto read entities that use them.\nParsed entities which are stored in an encoding other than\nUTF-8 or UTF-16 must begin with a  text\ndeclaration  containing an encoding declaration:\nEncoding Declaration \n [80]\u00a0 EncodingDecl \n  ::=  S \n'encoding'  Eq  \n('\"'  EncName  '\"' |\u00a0\n\"'\"  EncName  \"'\" )\n [81]\u00a0 EncName \n  ::=  [A-Za-z] ([A-Za-z0-9._] |\u00a0'-')* \n  /*  Encoding name contains only Latin characters */ \nIn the  document entity , the encoding\ndeclaration is part of the  XML declaration .\nThe  EncName  is the name of the encoding used.\n In an encoding declaration, the values\n\" UTF-8 \",\n\" UTF-16 \",\n\" ISO-10646-UCS-2 \", and\n\" ISO-10646-UCS-4 \" should be \nused for the various encodings and transformations of Unicode /\nISO/IEC 10646, the values\n\" ISO-8859-1 \",\n\" ISO-8859-2 \", ...\n\" ISO-8859-9 \" should be used for the parts of ISO 8859, and\nthe values\n\" ISO-2022-JP \",\n\" Shift_JIS \", and\n\" EUC-JP \"\nshould be used for the various encoded forms of JIS X-0208-1997.  XML\nprocessors may recognize other encodings; it is recommended that\ncharacter encodings registered (as  charset s) \nwith the Internet Assigned Numbers\nAuthority  [IANA] , other than those just listed, should be\nreferred to\nusing their registered names.\nNote that these registered names are defined to be \ncase-insensitive, so processors wishing to match against them \nshould do so in a case-insensitive\nway. \n In the absence of information provided by an external\ntransport protocol (e.g. HTTP or MIME), \nit is an  error  for an entity including\nan encoding declaration to be presented to the XML processor \nin an encoding other than that named in the declaration, \nfor an encoding declaration to occur other than at the beginning \nof an external entity, or for\nan entity which begins with neither a Byte Order Mark nor an encoding\ndeclaration to use an encoding other than UTF-8.\nNote that since ASCII\nis a subset of UTF-8, ordinary ASCII entities do not strictly need\nan encoding declaration. \n It is a  fatal error  when an XML processor\nencounters an entity with an encoding that it is unable to process. \n Examples of encoding declarations:\n <?xml\u00a0encoding='UTF-8'?> <?xml\u00a0encoding='EUC-JP'?> \n 4.4 XML Processor Treatment of Entities and References \n The table below summarizes the contexts in which character references,\nentity references, and invocations of unparsed entities might appear and the\nrequired behavior of an  XML processor  in\neach case.  \nThe labels in the leftmost column describe the recognition context:\n Reference in Content \n as a reference\nanywhere after the  start-tag  and\nbefore the  end-tag  of an element; corresponds\nto the nonterminal  content . \n Reference in Attribute Value \n as a reference within either the value of an attribute in a \n start-tag , or a default\nvalue in an  attribute declaration ;\ncorresponds to the nonterminal\n AttValue . \n Occurs as Attribute Value \n as a  Name , not a reference, appearing either as\nthe value of an \nattribute which has been declared as type  ENTITY , or as one of\nthe space-separated tokens in the value of an attribute which has been\ndeclared as type  ENTITIES .\n Reference in Entity Value \n as a reference\nwithin a parameter or internal entity's \n literal entity value  in\nthe entity's declaration; corresponds to the nonterminal \n EntityValue . \n Reference in DTD \n as a reference within either the internal or external subsets of the \n DTD , but outside\nof an  EntityValue  or\n AttValue . \n Entity\u00a0Type \n Character \n Parameter \n Internal General \n External\u00a0Parsed General \n Unparsed \n Reference in\u00a0Content \n Not\u00a0recognized \n Included \n Included\u00a0if\u00a0validating \n Forbidden \n Included \n Reference in\u00a0Attribute\u00a0Value \n Not\u00a0recognized \n Included\u00a0in\u00a0literal \n Forbidden \n Forbidden \n Included \n Occurs\u00a0as Attribute\u00a0Value \n Not\u00a0recognized \n Forbidden \n Forbidden \n Notify \n Not\u00a0recognized \n Reference in\u00a0EntityValue \n Included\u00a0in\u00a0literal \n Bypassed \n Bypassed \n Forbidden \n Included \n Reference in\u00a0DTD \n Included\u00a0as\u00a0PE \n Forbidden \n Forbidden \n Forbidden \n Forbidden \n 4.4.1 Not Recognized \n Outside the DTD, the  %  character has no\nspecial significance; thus, what would be parameter entity references in the\nDTD are not recognized as markup in  content .\nSimilarly, the names of unparsed entities are not recognized except\nwhen they appear in the value of an appropriately declared attribute.\n 4.4.2 Included \n An entity is \n included  when its \n replacement text  is retrieved \nand processed, in place of the reference itself,\nas though it were part of the document at the location the\nreference was recognized.\nThe replacement text may contain both \n character data \nand (except for parameter entities)  markup ,\nwhich must be recognized in\nthe usual way, except that the replacement text of entities used to escape\nmarkup delimiters (the entities  amp ,\n lt ,\n gt ,\n apos ,\n quot ) is always treated as\ndata.  (The string \" AT&amp;T; \" expands to\n\" AT&T; \" and the remaining ampersand is not recognized\nas an entity-reference delimiter.) \nA character reference is  included  when the indicated\ncharacter is processed in place of the reference itself.\n 4.4.3 Included If Validating \n When an XML processor recognizes a reference to a parsed entity, in order\nto  validate \nthe document, the processor must \n include  its\nreplacement text.\nIf the entity is external, and the processor is not\nattempting to validate the XML document, the\nprocessor  may , but need not, \ninclude the entity's replacement text.\nIf a non-validating parser does not include the replacement text,\nit must inform the application that it recognized, but did not\nread, the entity. \n This rule is based on the recognition that the automatic inclusion\nprovided by the SGML and XML entity mechanism, primarily designed\nto support modularity in authoring, is not necessarily \nappropriate for other applications, in particular document browsing.\nBrowsers, for example, when encountering an external parsed entity reference,\nmight choose to provide a visual indication of the entity's\npresence and retrieve it for display only on demand.\n 4.4.4 Forbidden \n The following are forbidden, and constitute\n fatal  errors:\n the appearance of a reference to an\n unparsed entity .\n the appearance of any character or general-entity reference in the\nDTD except within an  EntityValue  or \n AttValue . \n a reference to an external entity in an attribute value.\n 4.4.5 Included in Literal \n When an  entity reference  appears in an\nattribute value, or a parameter entity reference appears in a literal entity\nvalue, its  replacement text  is\nprocessed in place of the reference itself as though it\nwere part of the document at the location the reference was recognized,\nexcept that a single or double quote character in the replacement text\nis always treated as a normal data character and will not terminate the\nliteral. \nFor example, this is well-formed:\n <!ENTITY\u00a0%\u00a0YN\u00a0'\"Yes\"'\u00a0> <!ENTITY\u00a0WhatHeSaid\u00a0\"He\u00a0said\u00a0&YN;\"\u00a0> \nwhile this is not:\n <!ENTITY\u00a0EndAttr\u00a0\"27'\"\u00a0> <element\u00a0attribute='a-&EndAttr;> \n 4.4.6 Notify \n When the name of an  unparsed\nentity  appears as a token in the\nvalue of an attribute of declared type  ENTITY  or  ENTITIES ,\na validating processor must inform the\napplication of the  system  \nand  public  (if any)\nidentifiers for both the entity and its associated\n notation . \n 4.4.7 Bypassed \n When a general entity reference appears in the\n EntityValue  in an entity declaration,\nit is bypassed and left as is. \n 4.4.8 Included as PE \n Just as with external parsed entities, parameter entities\nneed only be  included if\nvalidating . \nWhen a parameter-entity reference is recognized in the DTD\nand included, its \n replacement\ntext  is enlarged by the attachment of one leading and one following\nspace (#x20) character; the intent is to constrain the replacement\ntext of parameter \nentities to contain an integral number of grammatical tokens in the DTD.\n 4.5 Construction of Internal Entity Replacement Text \n In discussing the treatment\nof internal entities, it is  \nuseful to distinguish two forms of the entity's value.\n The  literal\nentity value  is the quoted string actually\npresent in the entity declaration, corresponding to the\nnon-terminal  EntityValue .\n The  replacement\ntext  is the content of the entity, after\nreplacement of character references and parameter-entity\nreferences.\n The literal entity value \nas given in an internal entity declaration\n( EntityValue ) may contain character,\nparameter-entity, and general-entity references.\nSuch references must be contained entirely within the\nliteral entity value.\nThe actual replacement text that is \n included  as described above\nmust contain the  replacement text  of any \nparameter entities referred to, and must contain the character\nreferred to, in place of any character references in the\nliteral entity value; however,\ngeneral-entity references must be left as-is, unexpanded.\nFor example, given the following declarations:\n <!ENTITY\u00a0%\u00a0pub\u00a0\u00a0\u00a0\u00a0\"&#xc9;ditions\u00a0Gallimard\"\u00a0> <!ENTITY\u00a0\u00a0\u00a0rights\u00a0\"All\u00a0rights\u00a0reserved\"\u00a0> <!ENTITY\u00a0\u00a0\u00a0book\u00a0\u00a0\u00a0\"La\u00a0Peste:\u00a0Albert\u00a0Camus,\u00a0 &#xA9;\u00a01947\u00a0%pub;.\u00a0&rights;\"\u00a0> \nthen the replacement text for the entity \" book \" is:\n La\u00a0Peste:\u00a0Albert\u00a0Camus,\u00a0 \u00a9\u00a01947\u00a0\u00c9ditions\u00a0Gallimard.\u00a0&rights; \nThe general-entity reference \" &rights; \" would be expanded\nshould the reference \" &book; \" appear in the document's\ncontent or an attribute value. \n These simple rules may have complex interactions; for a detailed\ndiscussion of a difficult example, see\n\" D.\u00a0Expansion of Entity and Character References \".\n 4.6 Predefined Entities \n Entity and character\nreferences can both be used to  escape  the left angle bracket,\nampersand, and other delimiters.   A set of general entities\n( amp ,\n lt ,\n gt ,\n apos ,\n quot ) is specified for this purpose.\nNumeric character references may also be used; they are\nexpanded immediately when recognized and must be treated as\ncharacter data, so the numeric character references\n\" &#60; \" and \" &#38; \" may be used to \nescape  <  and  &  when they occur\nin character data. \n All XML processors must recognize these entities whether they\nare declared or not.  \n For interoperability ,\nvalid XML documents should declare these\nentities, like any others, before using them.\nIf the entities in question are declared, they must be declared\nas internal entities whose replacement text is the single\ncharacter being escaped or a character reference to\nthat character, as shown below.\n <!ENTITY\u00a0lt\u00a0\u00a0\u00a0\u00a0\u00a0\"&#38;#60;\">\u00a0 <!ENTITY\u00a0gt\u00a0\u00a0\u00a0\u00a0\u00a0\"&#62;\">\u00a0 <!ENTITY\u00a0amp\u00a0\u00a0\u00a0\u00a0\"&#38;#38;\">\u00a0 <!ENTITY\u00a0apos\u00a0\u00a0\u00a0\"&#39;\">\u00a0 <!ENTITY\u00a0quot\u00a0\u00a0\u00a0\"&#34;\">\u00a0 \nNote that the  <  and  &  characters\nin the declarations of \" lt \" and \" amp \"\nare doubly escaped to meet the requirement that entity replacement\nbe well-formed.\n 4.7 Notation Declarations \n Notations  identify by\nname the format of  unparsed\nentities , the\nformat of elements which bear a notation attribute, \nor the application to which  \na  processing instruction  is\naddressed. \n Notation declarations \nprovide a name for the notation, for use in\nentity and attribute-list declarations and in attribute specifications,\nand an external identifier for the notation which may allow an XML\nprocessor or its client application to locate a helper application\ncapable of processing data in the given notation.\nNotation Declarations \n [82]\u00a0 NotationDecl \n  ::=  '<!NOTATION'  S   Name \n S  \n( ExternalID  |\u00a0\n PublicID )\n S ? '>' \n [83]\u00a0 PublicID \n  ::=  'PUBLIC'  S \n PubidLiteral \n XML processors must provide applications with the name and external\nidentifier(s) of any notation declared and referred to in an attribute\nvalue, attribute definition, or entity declaration.  They may\nadditionally resolve the external identifier into the\n system identifier ,\nfile name, or other information needed to allow the\napplication to call a processor for data in the notation described.  (It\nis not an error, however, for XML documents to declare and refer to\nnotations for which notation-specific applications are not available on\nthe system where the XML processor or application is running.) \n 4.8 Document Entity \n The  document\nentity  serves as the root of the entity\ntree and a starting-point for an  XML\nprocessor .\nThis specification does\nnot specify how the document entity is to be located by an XML\nprocessor; unlike other entities, the document entity has no name and might\nwell appear on a processor input stream \nwithout any identification at all. \n 5. Conformance \n 5.1 Validating and Non-Validating Processors \n Conforming  XML processors  fall into two\nclasses: validating and non-validating. \n Validating and non-validating processors alike must report\nviolations of this specification's well-formedness constraints\nin the content of the\n document entity  and any \nother  parsed entities  that \nthey read. \n Validating processors  must report\nviolations of the constraints expressed by the declarations in the\n DTD , and\nfailures to fulfill the validity constraints given\nin this specification.\nTo accomplish this, validating XML processors must read and process the entire\nDTD and all external parsed entities referenced in the document.\n Non-validating processors are required to check only the \n document entity , including\nthe entire internal DTD subset, for well-formedness.\nWhile they are not required to check the document for validity,\nthey are required to \n process  all the declarations they read in the\ninternal DTD subset and in any parameter entity that they\nread, up to the first reference\nto a parameter entity that they do  not  read; that is to \nsay, they must\nuse the information in those declarations to\n normalize  attribute values,\n include  the replacement text of \ninternal entities, and supply \n default attribute values .\nThey must not  process \n entity declarations  or \n attribute-list declarations  \nencountered after a reference to a parameter entity that is not\nread, since the entity may have contained overriding declarations.\n 5.2 Using XML Processors \n The behavior of a validating XML processor is highly predictable; it\nmust read every piece of a document and report all well-formedness and\nvalidity violations.\nLess is required of a non-validating processor; it need not read any\npart of the document other than the document entity.\nThis has two effects that may be important to users of XML processors:\n Certain well-formedness errors, specifically those that require\nreading external entities, may not be detected by a non-validating processor.\nExamples include the constraints entitled \n Entity Declared , \n Parsed Entity , and\n No Recursion , as well\nas some of the cases described as\n forbidden  in \n\" 4.4\u00a0XML Processor Treatment of Entities and References \". \n The information passed from the processor to the application may\nvary, depending on whether the processor reads\nparameter and external entities.\nFor example, a non-validating processor may not \n normalize  attribute values,\n include  the replacement text of \ninternal entities, or supply \n default attribute values ,\nwhere doing so depends on having read declarations in \nexternal or parameter entities. \n For maximum reliability in interoperating between different XML\nprocessors, applications which use non-validating processors should not \nrely on any behaviors not required of such processors.\nApplications which require facilities such as the use of default\nattributes or internal entities which are declared in external\nentities should use validating XML processors. \n 6. Notation \n The formal grammar of XML is given in this specification using a simple\nExtended Backus-Naur Form (EBNF) notation.  Each rule in the grammar defines\none symbol, in the form\n symbol\u00a0::=\u00a0expression \n Symbols are written with an initial capital letter if they are\ndefined by a regular expression, or with an initial lower case letter \notherwise.\nLiteral strings are quoted.\n Within the expression on the right-hand side of a rule, the following\nexpressions are used to match strings of one or more characters:\n #xN \n where  N  is a hexadecimal integer, the\nexpression matches the character in ISO/IEC 10646 whose canonical\n(UCS-4) \ncode value, when interpreted as an unsigned binary number, has\nthe value indicated.  The number of leading zeros in the\n #xN  form is insignificant; the number of leading\nzeros in the corresponding code value \nis governed by the character\nencoding in use and is not significant for XML. \n [a-zA-Z] ,  [#xN-#xN] \n matches any  character  \nwith a value in the range(s) indicated (inclusive). \n [^a-z] ,  [^#xN-#xN] \n matches any  character  \nwith a value  outside  the\nrange indicated. \n [^abc] ,  [^#xN#xN#xN] \n matches any  character \nwith a value not among the characters given. \n \"string\" \n matches a literal string  matching \nthat given inside the double quotes. \n 'string' \n matches a literal string  matching \nthat given inside the single quotes. \nThese symbols may be combined to match more complex patterns as follows,\nwhere  A  and  B  represent simple expressions:\n ( expression ) \n expression  is treated as a unit \nand may be combined as described in this list. \n A? \n matches  A  or nothing; optional  A . \n A B \n matches  A  followed by  B . \n A | B \n matches  A  or  B  but not both. \n A - B \n matches any string that matches  A  but does not match\n B .\n A+ \n matches one or more occurrences of  A . \n A* \n matches zero or more occurrences of  A . \nOther notations used in the productions are:\n /* ... */ \n comment. \n [ wfc: ... ] \n well-formedness constraint; this identifies by name a \nconstraint on \n well-formed  documents\nassociated with a production. \n [ vc: ... ] \n validity constraint; this identifies by name a constraint on\n valid  documents associated with\na production. \n Appendices \n A. References \n A.1 Normative References \n IANA \n(Internet Assigned Numbers Authority)  Official Names for \nCharacter Sets ,\ned. Keld Simonsen et al.\nSee  ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets .\n IETF RFC 1766 \nIETF (Internet Engineering Task Force).\n RFC 1766:  Tags for the Identification of Languages ,\ned. H. Alvestrand.\n1995.\n ISO 639 \n(International Organization for Standardization).\n ISO 639:1988 (E).\nCode for the representation of names of languages. \n[Geneva]:  International Organization for\nStandardization, 1988. \n ISO 3166 \n(International Organization for Standardization).\n ISO 3166-1:1997 (E).\nCodes for the representation of names of countries and their subdivisions \n-- Part 1: Country codes \n[Geneva]:  International Organization for\nStandardization, 1997. \n ISO/IEC 10646 ISO\n(International Organization for Standardization).\n ISO/IEC 10646-1993 (E).  Information technology -- Universal\nMultiple-Octet Coded Character Set (UCS) -- Part 1:\nArchitecture and Basic Multilingual Plane. \n[Geneva]:  International Organization for\nStandardization, 1993 (plus amendments AM 1 through AM 7).\n Unicode The Unicode Consortium.\n The Unicode Standard, Version 2.0. \nReading, Mass.:  Addison-Wesley Developers Press, 1996. \n A.2 Other References \n Aho/Ullman Aho, Alfred V., \nRavi Sethi, and Jeffrey D. Ullman.\n Compilers:  Principles, Techniques, and Tools .\nReading:  Addison-Wesley, 1986, rpt. corr. 1988. \n Berners-Lee et al. \nBerners-Lee, T., R. Fielding, and L. Masinter.\n Uniform Resource Identifiers (URI):  Generic Syntax and\nSemantics .\n1997.\n(Work in progress; see updates to RFC1738.) \n Br\u00fcggemann-Klein Br\u00fcggemann-Klein, Anne.\n Regular Expressions into Finite Automata .\nExtended abstract in I. Simon, Hrsg., LATIN 1992, \nS. 97-98. Springer-Verlag, Berlin 1992. \nFull Version in Theoretical Computer Science 120: 197-213, 1993.\n Br\u00fcggemann-Klein and Wood Br\u00fcggemann-Klein, Anne,\nand Derick Wood.\n Deterministic Regular Languages .\nUniversit\u00e4t Freiburg, Institut f\u00fcr Informatik,\nBericht 38, Oktober 1991.\n Clark James Clark.\nComparison of SGML and XML. See\n http://www.w3.org/TR/NOTE-sgml-xml-971215 .\n IETF RFC1738 \nIETF (Internet Engineering Task Force).\n RFC 1738:  Uniform Resource Locators (URL) , \ned. T. Berners-Lee, L. Masinter, M. McCahill.\n1994.\n IETF RFC1808 \nIETF (Internet Engineering Task Force).\n RFC 1808:  Relative Uniform Resource Locators , \ned. R. Fielding.\n1995.\n IETF RFC2141 \nIETF (Internet Engineering Task Force).\n RFC 2141:  URN Syntax , \ned. R. Moats.\n1997.\n ISO 8879 ISO\n(International Organization for Standardization).\n ISO 8879:1986(E).  Information processing -- Text and Office\nSystems -- Standard Generalized Markup Language (SGML).   First\nedition -- 1986-10-15.  [Geneva]:  International Organization for\nStandardization, 1986.\n ISO/IEC 10744 ISO\n(International Organization for Standardization).\n ISO/IEC 10744-1992 (E).  Information technology --\nHypermedia/Time-based Structuring Language (HyTime).\n[Geneva]:  International Organization for\nStandardization, 1992.\n Extended Facilities Annexe. \n[Geneva]:  International Organization for\nStandardization, 1996. \n B. Character Classes \n Following the characteristics defined in the Unicode standard,\ncharacters are classed as base characters (among others, these\ncontain the alphabetic characters of the Latin alphabet, without\ndiacritics), ideographic characters, and combining characters (among\nothers, this class contains most diacritics); these classes combine\nto form the class of letters.  Digits and extenders are\nalso distinguished.\nCharacters \n [84]\u00a0 Letter \n  ::=  BaseChar  \n|\u00a0 Ideographic   \n [85]\u00a0 BaseChar \n  ::=  [#x0041-#x005A]\n|\u00a0[#x0061-#x007A]\n|\u00a0[#x00C0-#x00D6]\n|\u00a0[#x00D8-#x00F6]\n|\u00a0[#x00F8-#x00FF]\n|\u00a0[#x0100-#x0131]\n|\u00a0[#x0134-#x013E]\n|\u00a0[#x0141-#x0148]\n|\u00a0[#x014A-#x017E]\n|\u00a0[#x0180-#x01C3]\n|\u00a0[#x01CD-#x01F0]\n|\u00a0[#x01F4-#x01F5]\n|\u00a0[#x01FA-#x0217]\n|\u00a0[#x0250-#x02A8]\n|\u00a0[#x02BB-#x02C1]\n|\u00a0#x0386\n|\u00a0[#x0388-#x038A]\n|\u00a0#x038C\n|\u00a0[#x038E-#x03A1]\n|\u00a0[#x03A3-#x03CE]\n|\u00a0[#x03D0-#x03D6]\n|\u00a0#x03DA\n|\u00a0#x03DC\n|\u00a0#x03DE\n|\u00a0#x03E0\n|\u00a0[#x03E2-#x03F3]\n|\u00a0[#x0401-#x040C]\n|\u00a0[#x040E-#x044F]\n|\u00a0[#x0451-#x045C]\n|\u00a0[#x045E-#x0481]\n|\u00a0[#x0490-#x04C4]\n|\u00a0[#x04C7-#x04C8]\n|\u00a0[#x04CB-#x04CC]\n|\u00a0[#x04D0-#x04EB]\n|\u00a0[#x04EE-#x04F5]\n|\u00a0[#x04F8-#x04F9]\n|\u00a0[#x0531-#x0556]\n|\u00a0#x0559\n|\u00a0[#x0561-#x0586]\n|\u00a0[#x05D0-#x05EA]\n|\u00a0[#x05F0-#x05F2]\n|\u00a0[#x0621-#x063A]\n|\u00a0[#x0641-#x064A]\n|\u00a0[#x0671-#x06B7]\n|\u00a0[#x06BA-#x06BE]\n|\u00a0[#x06C0-#x06CE]\n|\u00a0[#x06D0-#x06D3]\n|\u00a0#x06D5\n|\u00a0[#x06E5-#x06E6]\n|\u00a0[#x0905-#x0939]\n|\u00a0#x093D\n|\u00a0[#x0958-#x0961]\n|\u00a0[#x0985-#x098C]\n|\u00a0[#x098F-#x0990]\n|\u00a0[#x0993-#x09A8]\n|\u00a0[#x09AA-#x09B0]\n|\u00a0#x09B2\n|\u00a0[#x09B6-#x09B9]\n|\u00a0[#x09DC-#x09DD]\n|\u00a0[#x09DF-#x09E1]\n|\u00a0[#x09F0-#x09F1]\n|\u00a0[#x0A05-#x0A0A]\n|\u00a0[#x0A0F-#x0A10]\n|\u00a0[#x0A13-#x0A28]\n|\u00a0[#x0A2A-#x0A30]\n|\u00a0[#x0A32-#x0A33]\n|\u00a0[#x0A35-#x0A36]\n|\u00a0[#x0A38-#x0A39]\n|\u00a0[#x0A59-#x0A5C]\n|\u00a0#x0A5E\n|\u00a0[#x0A72-#x0A74]\n|\u00a0[#x0A85-#x0A8B]\n|\u00a0#x0A8D\n|\u00a0[#x0A8F-#x0A91]\n|\u00a0[#x0A93-#x0AA8]\n|\u00a0[#x0AAA-#x0AB0]\n|\u00a0[#x0AB2-#x0AB3]\n|\u00a0[#x0AB5-#x0AB9]\n|\u00a0#x0ABD\n|\u00a0#x0AE0\n|\u00a0[#x0B05-#x0B0C]\n|\u00a0[#x0B0F-#x0B10]\n|\u00a0[#x0B13-#x0B28]\n|\u00a0[#x0B2A-#x0B30]\n|\u00a0[#x0B32-#x0B33]\n|\u00a0[#x0B36-#x0B39]\n|\u00a0#x0B3D\n|\u00a0[#x0B5C-#x0B5D]\n|\u00a0[#x0B5F-#x0B61]\n|\u00a0[#x0B85-#x0B8A]\n|\u00a0[#x0B8E-#x0B90]\n|\u00a0[#x0B92-#x0B95]\n|\u00a0[#x0B99-#x0B9A]\n|\u00a0#x0B9C\n|\u00a0[#x0B9E-#x0B9F]\n|\u00a0[#x0BA3-#x0BA4]\n|\u00a0[#x0BA8-#x0BAA]\n|\u00a0[#x0BAE-#x0BB5]\n|\u00a0[#x0BB7-#x0BB9]\n|\u00a0[#x0C05-#x0C0C]\n|\u00a0[#x0C0E-#x0C10]\n|\u00a0[#x0C12-#x0C28]\n|\u00a0[#x0C2A-#x0C33]\n|\u00a0[#x0C35-#x0C39]\n|\u00a0[#x0C60-#x0C61]\n|\u00a0[#x0C85-#x0C8C]\n|\u00a0[#x0C8E-#x0C90]\n|\u00a0[#x0C92-#x0CA8]\n|\u00a0[#x0CAA-#x0CB3]\n|\u00a0[#x0CB5-#x0CB9]\n|\u00a0#x0CDE\n|\u00a0[#x0CE0-#x0CE1]\n|\u00a0[#x0D05-#x0D0C]\n|\u00a0[#x0D0E-#x0D10]\n|\u00a0[#x0D12-#x0D28]\n|\u00a0[#x0D2A-#x0D39]\n|\u00a0[#x0D60-#x0D61]\n|\u00a0[#x0E01-#x0E2E]\n|\u00a0#x0E30\n|\u00a0[#x0E32-#x0E33]\n|\u00a0[#x0E40-#x0E45]\n|\u00a0[#x0E81-#x0E82]\n|\u00a0#x0E84\n|\u00a0[#x0E87-#x0E88]\n|\u00a0#x0E8A\n|\u00a0#x0E8D\n|\u00a0[#x0E94-#x0E97]\n|\u00a0[#x0E99-#x0E9F]\n|\u00a0[#x0EA1-#x0EA3]\n|\u00a0#x0EA5\n|\u00a0#x0EA7\n|\u00a0[#x0EAA-#x0EAB]\n|\u00a0[#x0EAD-#x0EAE]\n|\u00a0#x0EB0\n|\u00a0[#x0EB2-#x0EB3]\n|\u00a0#x0EBD\n|\u00a0[#x0EC0-#x0EC4]\n|\u00a0[#x0F40-#x0F47]\n|\u00a0[#x0F49-#x0F69]\n|\u00a0[#x10A0-#x10C5]\n|\u00a0[#x10D0-#x10F6]\n|\u00a0#x1100\n|\u00a0[#x1102-#x1103]\n|\u00a0[#x1105-#x1107]\n|\u00a0#x1109\n|\u00a0[#x110B-#x110C]\n|\u00a0[#x110E-#x1112]\n|\u00a0#x113C\n|\u00a0#x113E\n|\u00a0#x1140\n|\u00a0#x114C\n|\u00a0#x114E\n|\u00a0#x1150\n|\u00a0[#x1154-#x1155]\n|\u00a0#x1159\n|\u00a0[#x115F-#x1161]\n|\u00a0#x1163\n|\u00a0#x1165\n|\u00a0#x1167\n|\u00a0#x1169\n|\u00a0[#x116D-#x116E]\n|\u00a0[#x1172-#x1173]\n|\u00a0#x1175\n|\u00a0#x119E\n|\u00a0#x11A8\n|\u00a0#x11AB\n|\u00a0[#x11AE-#x11AF]\n|\u00a0[#x11B7-#x11B8]\n|\u00a0#x11BA\n|\u00a0[#x11BC-#x11C2]\n|\u00a0#x11EB\n|\u00a0#x11F0\n|\u00a0#x11F9\n|\u00a0[#x1E00-#x1E9B]\n|\u00a0[#x1EA0-#x1EF9]\n|\u00a0[#x1F00-#x1F15]\n|\u00a0[#x1F18-#x1F1D]\n|\u00a0[#x1F20-#x1F45]\n|\u00a0[#x1F48-#x1F4D]\n|\u00a0[#x1F50-#x1F57]\n|\u00a0#x1F59\n|\u00a0#x1F5B\n|\u00a0#x1F5D\n|\u00a0[#x1F5F-#x1F7D]\n|\u00a0[#x1F80-#x1FB4]\n|\u00a0[#x1FB6-#x1FBC]\n|\u00a0#x1FBE\n|\u00a0[#x1FC2-#x1FC4]\n|\u00a0[#x1FC6-#x1FCC]\n|\u00a0[#x1FD0-#x1FD3]\n|\u00a0[#x1FD6-#x1FDB]\n|\u00a0[#x1FE0-#x1FEC]\n|\u00a0[#x1FF2-#x1FF4]\n|\u00a0[#x1FF6-#x1FFC]\n|\u00a0#x2126\n|\u00a0[#x212A-#x212B]\n|\u00a0#x212E\n|\u00a0[#x2180-#x2182]\n|\u00a0[#x3041-#x3094]\n|\u00a0[#x30A1-#x30FA]\n|\u00a0[#x3105-#x312C]\n|\u00a0[#xAC00-#xD7A3]\n [86]\u00a0 Ideographic \n  ::=  [#x4E00-#x9FA5]\n|\u00a0#x3007\n|\u00a0[#x3021-#x3029]\n [87]\u00a0 CombiningChar \n  ::=  [#x0300-#x0345]\n|\u00a0[#x0360-#x0361]\n|\u00a0[#x0483-#x0486]\n|\u00a0[#x0591-#x05A1]\n|\u00a0[#x05A3-#x05B9]\n|\u00a0[#x05BB-#x05BD]\n|\u00a0#x05BF\n|\u00a0[#x05C1-#x05C2]\n|\u00a0#x05C4\n|\u00a0[#x064B-#x0652]\n|\u00a0#x0670\n|\u00a0[#x06D6-#x06DC]\n|\u00a0[#x06DD-#x06DF]\n|\u00a0[#x06E0-#x06E4]\n|\u00a0[#x06E7-#x06E8]\n|\u00a0[#x06EA-#x06ED]\n|\u00a0[#x0901-#x0903]\n|\u00a0#x093C\n|\u00a0[#x093E-#x094C]\n|\u00a0#x094D\n|\u00a0[#x0951-#x0954]\n|\u00a0[#x0962-#x0963]\n|\u00a0[#x0981-#x0983]\n|\u00a0#x09BC\n|\u00a0#x09BE\n|\u00a0#x09BF\n|\u00a0[#x09C0-#x09C4]\n|\u00a0[#x09C7-#x09C8]\n|\u00a0[#x09CB-#x09CD]\n|\u00a0#x09D7\n|\u00a0[#x09E2-#x09E3]\n|\u00a0#x0A02\n|\u00a0#x0A3C\n|\u00a0#x0A3E\n|\u00a0#x0A3F\n|\u00a0[#x0A40-#x0A42]\n|\u00a0[#x0A47-#x0A48]\n|\u00a0[#x0A4B-#x0A4D]\n|\u00a0[#x0A70-#x0A71]\n|\u00a0[#x0A81-#x0A83]\n|\u00a0#x0ABC\n|\u00a0[#x0ABE-#x0AC5]\n|\u00a0[#x0AC7-#x0AC9]\n|\u00a0[#x0ACB-#x0ACD]\n|\u00a0[#x0B01-#x0B03]\n|\u00a0#x0B3C\n|\u00a0[#x0B3E-#x0B43]\n|\u00a0[#x0B47-#x0B48]\n|\u00a0[#x0B4B-#x0B4D]\n|\u00a0[#x0B56-#x0B57]\n|\u00a0[#x0B82-#x0B83]\n|\u00a0[#x0BBE-#x0BC2]\n|\u00a0[#x0BC6-#x0BC8]\n|\u00a0[#x0BCA-#x0BCD]\n|\u00a0#x0BD7\n|\u00a0[#x0C01-#x0C03]\n|\u00a0[#x0C3E-#x0C44]\n|\u00a0[#x0C46-#x0C48]\n|\u00a0[#x0C4A-#x0C4D]\n|\u00a0[#x0C55-#x0C56]\n|\u00a0[#x0C82-#x0C83]\n|\u00a0[#x0CBE-#x0CC4]\n|\u00a0[#x0CC6-#x0CC8]\n|\u00a0[#x0CCA-#x0CCD]\n|\u00a0[#x0CD5-#x0CD6]\n|\u00a0[#x0D02-#x0D03]\n|\u00a0[#x0D3E-#x0D43]\n|\u00a0[#x0D46-#x0D48]\n|\u00a0[#x0D4A-#x0D4D]\n|\u00a0#x0D57\n|\u00a0#x0E31\n|\u00a0[#x0E34-#x0E3A]\n|\u00a0[#x0E47-#x0E4E]\n|\u00a0#x0EB1\n|\u00a0[#x0EB4-#x0EB9]\n|\u00a0[#x0EBB-#x0EBC]\n|\u00a0[#x0EC8-#x0ECD]\n|\u00a0[#x0F18-#x0F19]\n|\u00a0#x0F35\n|\u00a0#x0F37\n|\u00a0#x0F39\n|\u00a0#x0F3E\n|\u00a0#x0F3F\n|\u00a0[#x0F71-#x0F84]\n|\u00a0[#x0F86-#x0F8B]\n|\u00a0[#x0F90-#x0F95]\n|\u00a0#x0F97\n|\u00a0[#x0F99-#x0FAD]\n|\u00a0[#x0FB1-#x0FB7]\n|\u00a0#x0FB9\n|\u00a0[#x20D0-#x20DC]\n|\u00a0#x20E1\n|\u00a0[#x302A-#x302F]\n|\u00a0#x3099\n|\u00a0#x309A\n [88]\u00a0 Digit \n  ::=  [#x0030-#x0039]\n|\u00a0[#x0660-#x0669]\n|\u00a0[#x06F0-#x06F9]\n|\u00a0[#x0966-#x096F]\n|\u00a0[#x09E6-#x09EF]\n|\u00a0[#x0A66-#x0A6F]\n|\u00a0[#x0AE6-#x0AEF]\n|\u00a0[#x0B66-#x0B6F]\n|\u00a0[#x0BE7-#x0BEF]\n|\u00a0[#x0C66-#x0C6F]\n|\u00a0[#x0CE6-#x0CEF]\n|\u00a0[#x0D66-#x0D6F]\n|\u00a0[#x0E50-#x0E59]\n|\u00a0[#x0ED0-#x0ED9]\n|\u00a0[#x0F20-#x0F29]\n [89]\u00a0 Extender \n  ::=  #x00B7\n|\u00a0#x02D0\n|\u00a0#x02D1\n|\u00a0#x0387\n|\u00a0#x0640\n|\u00a0#x0E46\n|\u00a0#x0EC6\n|\u00a0#x3005\n|\u00a0[#x3031-#x3035]\n|\u00a0[#x309D-#x309E]\n|\u00a0[#x30FC-#x30FE]\n The character classes defined here can be derived from the\nUnicode character database as follows:\nName start characters must have one of the categories Ll, Lu,\nLo, Lt, Nl.\nName characters other than Name-start characters \nmust have one of the categories Mc, Me, Mn, Lm, or Nd.\nCharacters in the compatibility area (i.e. with character code\ngreater than #xF900 and less than #xFFFE) are not allowed in XML\nnames.\nCharacters which have a font or compatibility decomposition (i.e. those\nwith a \"compatibility formatting tag\" in field 5 of the database --\nmarked by field 5 beginning with a \"<\") are not allowed.\nThe following characters are treated as name-start characters\nrather than name characters, because the property file classifies\nthem as Alphabetic:  [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.\nCharacters #x20DD-#x20E0 are excluded (in accordance with \nUnicode, section 5.14).\nCharacter #x00B7 is classified as an extender, because the\nproperty list so identifies it.\nCharacter #x0387 is added as a name character, because #x00B7\nis its canonical equivalent.\nCharacters ':' and '_' are allowed as name-start characters.\nCharacters '-' and '.' are allowed as name characters.\n C. XML and SGML (Non-Normative) \n XML is designed to be a subset of SGML, in that every\n valid  XML document should also be a\nconformant SGML document.\nFor a detailed comparison of the additional restrictions that XML places on\ndocuments beyond those of SGML, see  [Clark] .\n D. Expansion of Entity and Character References (Non-Normative) \n This appendix contains some examples illustrating the\nsequence of entity- and character-reference recognition and\nexpansion, as specified in \" 4.4\u00a0XML Processor Treatment of Entities and References \". \nIf the DTD contains the declaration \n <!ENTITY\u00a0example\u00a0\"<p>An\u00a0ampersand\u00a0(&#38;#38;)\u00a0may\u00a0be\u00a0escaped numerically\u00a0(&#38;#38;#38;)\u00a0or\u00a0with\u00a0a\u00a0general\u00a0entity (&amp;amp;).</p>\"\u00a0> \nthen the XML processor will recognize the character references \nwhen it parses the entity declaration, and resolve them before \nstoring the following string as the\nvalue of the entity \" example \":\n <p>An\u00a0ampersand\u00a0(&#38;)\u00a0may\u00a0be\u00a0escaped numerically\u00a0(&#38;#38;)\u00a0or\u00a0with\u00a0a\u00a0general\u00a0entity (&amp;amp;).</p> \nA reference in the document to \" &example; \" \nwill cause the text to be reparsed, at which time the \nstart- and end-tags of the \" p \" element will be recognized \nand the three references will be recognized and expanded, \nresulting in a \" p \" element with the following content\n(all data, no delimiters or markup):\n An\u00a0ampersand\u00a0(&)\u00a0may\u00a0be\u00a0escaped numerically\u00a0(&#38;)\u00a0or\u00a0with\u00a0a\u00a0general\u00a0entity (&amp;). \n A more complex example will illustrate the rules and their\neffects fully.  In the following example, the line numbers are\nsolely for reference.\n 1\u00a0<?xml\u00a0version='1.0'?> 2\u00a0<!DOCTYPE\u00a0test\u00a0[ 3\u00a0<!ELEMENT\u00a0test\u00a0(#PCDATA)\u00a0> 4\u00a0<!ENTITY\u00a0%\u00a0xx\u00a0'&#37;zz;'> 5\u00a0<!ENTITY\u00a0%\u00a0zz\u00a0'&#60;!ENTITY\u00a0tricky\u00a0\"error-prone\"\u00a0>'\u00a0> 6\u00a0%xx; 7\u00a0]> 8\u00a0<test>This\u00a0sample\u00a0shows\u00a0a\u00a0&tricky;\u00a0method.</test> \nThis produces the following:\n in line 4, the reference to character 37 is expanded immediately,\nand the parameter entity \" xx \" is stored in the symbol\ntable with the value \" %zz; \".  Since the replacement text\nis not rescanned, the reference to parameter entity \" zz \"\nis not recognized.  (And it would be an error if it were, since\n\" zz \" is not yet declared.) \n in line 5, the character reference \" &#60; \" is\nexpanded immediately and the parameter entity \" zz \" is\nstored with the replacement text \n\" <!ENTITY tricky \"error-prone\" > \",\nwhich is a well-formed entity declaration. \n in line 6, the reference to \" xx \" is recognized,\nand the replacement text of \" xx \" (namely \n\" %zz; \") is parsed.  The reference to \" zz \"\nis recognized in its turn, and its replacement text \n(\" <!ENTITY tricky \"error-prone\" > \") is parsed.\nThe general entity \" tricky \" has now been\ndeclared, with the replacement text \" error-prone \". \nin line 8, the reference to the general entity \" tricky \" is\nrecognized, and it is expanded, so the full content of the\n\" test \" element is the self-describing (and ungrammatical) string\n This sample shows a error-prone method. \n E. Deterministic Content Models (Non-Normative) \n For compatibility , it is\nrequired\nthat content models in element type declarations be deterministic.  \n SGML\nrequires deterministic content models (it calls them\n\"unambiguous\"); XML processors built using SGML systems may\nflag non-deterministic content models as errors. \n For example, the content model  ((b, c) | (b, d))  is\nnon-deterministic, because given an initial  b  the parser\ncannot know which  b  in the model is being matched without\nlooking ahead to see which element follows the  b .\nIn this case, the two references to\n b  can be collapsed \ninto a single reference, making the model read\n (b, (c | d)) .  An initial  b  now clearly\nmatches only a single name in the content model.  The parser doesn't\nneed to look ahead to see what follows; either  c  or\n d  would be accepted. \n More formally:  a finite state automaton may be constructed from the\ncontent model using the standard algorithms, e.g. algorithm 3.5 \nin section 3.9\nof Aho, Sethi, and Ullman  [Aho/Ullman] .\nIn many such algorithms, a follow set is constructed for each \nposition in the regular expression (i.e., each leaf \nnode in the \nsyntax tree for the regular expression);\nif any position has a follow set in which \nmore than one following position is \nlabeled with the same element type name, \nthen the content model is in error\nand may be reported as an error.\n Algorithms exist which allow many but not all non-deterministic\ncontent models to be reduced automatically to equivalent deterministic\nmodels; see Br\u00fcggemann-Klein 1991  [Br\u00fcggemann-Klein] . \n F. Autodetection of Character Encodings (Non-Normative) \n The XML encoding declaration functions as an internal label on each\nentity, indicating which character encoding is in use.  Before an XML\nprocessor can read the internal label, however, it apparently has to\nknow what character encoding is in use--which is what the internal label\nis trying to indicate.  In the general case, this is a hopeless\nsituation. It is not entirely hopeless in XML, however, because XML\nlimits the general case in two ways:  each implementation is assumed\nto support only a  finite set of character encodings, and the XML\nencoding declaration is restricted in position and content in order to\nmake it feasible to autodetect the character encoding in use in each\nentity in normal cases.  Also, in many cases other sources of information\nare available in addition to the XML data stream itself.  \nTwo cases may be distinguished, \ndepending on whether the XML entity is presented to the\nprocessor without, or with, any accompanying\n(external) information.  We consider the first case first.\nBecause each XML entity not in UTF-8 or UTF-16 format  must \nbegin with an XML encoding declaration, in which the first  characters\nmust be ' <?xml ', any conforming processor can detect,\nafter two to four octets of input, which of the following cases apply. \nIn reading this list, it may help to know that in UCS-4, '<' is\n\" #x0000003C \" and '?' is \" #x0000003F \", and the Byte\nOrder Mark required of UTF-16 data streams is \" #xFEFF \". \n 00 00 00 3C : UCS-4, big-endian machine (1234 order)\n 3C 00 00 00 : UCS-4, little-endian machine (4321 order)\n 00 00 3C 00 : UCS-4, unusual octet order (2143)\n 00 3C 00 00 : UCS-4, unusual octet order (3412)\n FE FF : UTF-16, big-endian\n FF FE : UTF-16, little-endian\n 00 3C 00 3F : UTF-16, big-endian, no Byte Order Mark\n(and thus, strictly speaking, in error)\n 3C 00 3F 00 : UTF-16, little-endian, no Byte Order Mark\n(and thus, strictly speaking, in error)\n 3C 3F 78 6D : UTF-8, ISO 646, ASCII, some part of ISO 8859, \nShift-JIS, EUC, or any other 7-bit, 8-bit, or mixed-width encoding\nwhich ensures that the characters of ASCII have their normal positions,\nwidth,\nand values; the actual encoding declaration must be read to \ndetect which of these applies, but since all of these encodings\nuse the same bit patterns for the ASCII characters, the encoding \ndeclaration itself may be read reliably\n 4C 6F A7 94 : EBCDIC (in some flavor; the full\nencoding declaration must be read to tell which code page is in \nuse)\nother: UTF-8 without an encoding declaration, or else \nthe data stream is corrupt, fragmentary, or enclosed in\na wrapper of some kind\nThis level of autodetection is enough to read the XML encoding\ndeclaration and parse the character-encoding identifier, which is\nstill necessary to distinguish the individual members of each family\nof encodings (e.g. to tell  UTF-8 from 8859, and the parts of 8859\nfrom each other, or to distinguish the specific EBCDIC code page in\nuse, and so on).\nBecause the contents of the encoding declaration are restricted to\nASCII characters, a processor can reliably read the entire encoding\ndeclaration as soon as it has detected which family of encodings is in\nuse.  Since in practice, all widely used character encodings fall into\none of the categories above, the XML encoding declaration allows\nreasonably reliable in-band labeling of character encodings, even when\nexternal sources of information at the operating-system or\ntransport-protocol level are unreliable.\nOnce the processor has detected the character encoding in use, it can\nact appropriately, whether by invoking a separate input routine for\neach case, or by calling the proper conversion function on each\ncharacter of input. \nLike any self-labeling system, the XML encoding declaration will not\nwork if any software changes the entity's character set or encoding\nwithout updating the encoding declaration.  Implementors of\ncharacter-encoding routines should be careful to ensure the accuracy\nof the internal and external information used to label the entity.\n The second possible case occurs when the XML entity is accompanied\nby encoding information, as in some file systems and some network\nprotocols.\nWhen multiple sources of information are available,\ntheir relative\npriority and the preferred method of handling conflict should be\nspecified as part of the higher-level protocol used to deliver XML.\nRules for the relative priority of the internal label and the\nMIME-type label in an external header, for example, should be part of the\nRFC document defining the text/xml and application/xml MIME types. In\nthe interests of interoperability, however, the following rules\nare recommended.\n If an XML entity is in a file, the Byte-Order Mark\nand encoding-declaration PI are used (if present) to determine the\ncharacter encoding.  All other heuristics and sources of information\nare solely for error recovery.\n If an XML entity is delivered with a\nMIME type of text/xml, then the  charset  parameter\non the MIME type determines the\ncharacter encoding method; all other heuristics and sources of\ninformation are solely for error recovery.\n If an XML entity is delivered \nwith a\nMIME type of application/xml, then the Byte-Order Mark and\nencoding-declaration PI are used (if present) to determine the\ncharacter encoding.  All other heuristics and sources of\ninformation are solely for error recovery.\nThese rules apply only in the absence of protocol-level documentation;\nin particular, when the MIME types text/xml and application/xml are\ndefined, the recommendations of the relevant RFC will supersede\nthese rules.\n G. W3C XML Working Group (Non-Normative) \n This specification was prepared and approved for publication by the\nW3C XML Working Group (WG).  WG approval of this specification does\nnot necessarily imply that all WG members voted for its approval.  \nThe current and former members of the XML WG are: \nJon Bosak, Sun (Chair);\nJames Clark (Technical Lead);\nTim Bray, Textuality and Netscape (XML Co-editor);\nJean Paoli, Microsoft (XML Co-editor);\nC. M. Sperberg-McQueen, U. of Ill. (XML\nCo-editor);\nDan Connolly, W3C (W3C Liaison);\nPaula Angerstein, Texcel;\nSteve DeRose, INSO;\nDave Hollander, HP;\nEliot Kimber, ISOGEN;\nEve Maler, ArborText;\nTom Magliery, NCSA;\nMurray Maloney, Muzmo and Grif;\nMakoto Murata, Fuji Xerox Information Systems;\nJoel Nava, Adobe;\nConleth O'Connell, Vignette;\nPeter Sharpe, SoftQuad;\nJohn Tigue, DataChannel\nCopyright  \u00a0\u00a9\u00a0 1998  W3C \n( MIT ,\n INRIA ,\n Keio  ), All Rights Reserved. W3C\n liability, \n trademark ,\n document\nuse  and\n software\nlicensing  rules apply."}